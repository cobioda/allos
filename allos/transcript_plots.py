"""The TranscriptPlots class is defined to facilitate the visualization of transcript structures."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/001_transcript_plots.ipynb.

# %% auto 0
__all__ = ['merge_intervals', 'TranscriptPlots']

# %% ../nbs/001_transcript_plots.ipynb 3
import numpy as np
import requests
import sys
import matplotlib.pyplot as plt


# %% ../nbs/001_transcript_plots.ipynb 7
import sys, requests
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

def merge_intervals(intervals):
    """Merge a list of [start, end] intervals."""
    if not intervals:
        return []
    intervals = sorted(intervals, key=lambda x: x[0])
    merged = [intervals[0]]
    for current in intervals[1:]:
        prev = merged[-1]
        if current[0] <= prev[1]:
            merged[-1] = [prev[0], max(prev[1], current[1])]
        else:
            merged.append(current)
    return merged

class TranscriptPlots:
    def __init__(self, gtf_file=None, reference_fasta=None, intron_scale=0.1):
        """
        intron_scale: factor (between 0 and 1) by which intronic regions are compressed.
        """
        self.transcript_data = None
        self.intron_scale = intron_scale
        self.colors = ['blue', 'green', 'orange', 'purple', 'brown']
        if gtf_file is not None:
            from allos.transcript_data import TranscriptData
            self.transcript_data = TranscriptData(gtf_file=gtf_file, reference_fasta=reference_fasta)

    def get_transcript_info(self, transcript_id):
        if self.transcript_data is None:
            raise NotImplementedError("Transcript info not available; please supply a GTF file.")
        else:
            return self.transcript_data.get_transcript_info(transcript_id)

    def _get_coord_from_tscrpt_id(self, transcript_id):
        """
        Returns a tuple (exon_list, strand).
        Each exon is stored as [end, start].
        """
        if self.transcript_data is None:
            if '.' in transcript_id:
                transcript_id = transcript_id.split('.')[0]
            server = "https://rest.ensembl.org"
            ext = "/lookup/id/" + transcript_id + "?expand=1"
            r = requests.get(server+ext, headers={"Content-Type": "application/json"})
            if not r.ok:
                r.raise_for_status()
                sys.exit()
            decoded = r.json()
            exon_list = list(decoded['Exon'])
            exon_coord = []
            for e in exon_list:
                exon_coord.append([e.get('end'), e.get('start')])
            strand = decoded['strand']
            return (exon_coord, strand)
        else:
            return self.transcript_data.get_exon_coords_and_strand(transcript_id)

    def _make_global_mapping(self, all_exons):
        """
        Build a mapping function f(x) that compresses introns but leaves exons at full length,
        normalizing the entire region to [0..1].
        """
        intervals = []
        for exon_list in all_exons:
            for e in exon_list:
                s, e_ = min(e[0], e[1]), max(e[0], e[1])
                intervals.append([s, e_])
        union_exons = merge_intervals(intervals)
        if not union_exons:
            raise ValueError("No exonic intervals found.")

        global_start = min(i[0] for i in union_exons)
        global_end   = max(i[1] for i in union_exons)

        def exon_length_before(x):
            total = 0
            for (a, b) in union_exons:
                if x <= a:
                    break
                total += min(b, x) - a
            return total

        def mapping_fn_unscaled(x):
            # Introns are scaled by self.intron_scale, exons remain full length
            # => f(x) = intron_scale*(x - global_start) + (1-intron_scale)*exonic_length_before(x)
            total   = x - global_start
            exonic  = exon_length_before(x)
            return self.intron_scale * total + (1 - self.intron_scale) * exonic

        # Normalize so that f(global_end) == 1
        scaled_global_end = mapping_fn_unscaled(global_end)
        def mapping_fn_normalized(x):
            return mapping_fn_unscaled(x) / scaled_global_end

        return mapping_fn_normalized

    def _draw_transcript(self, exons, direction, color, transcript_name, mapping_fn,
                         offset=0, with_cds=False):
        """
        Draw the exons/introns in a single transcript using the global mapping_fn,
        so everything lines up across transcripts with identical coordinates.
        This version preserves the original exon shapes (including UTR/CDS splits on first and last exons)
        but removes any special CDS coloring.
        """
        height = 0.2
        ax = plt.gca()
        # Optimization: cache mapping_fn results to avoid redundant computations.
        cache = {}
        def cached_map(x):
            if x not in cache:
                cache[x] = mapping_fn(x)
            return cache[x]

        # For forward-stranded transcripts, exons are [end, start] with end < start.
        # We'll pick indices so that j is 'left' and k is 'right' in genomic sense.
        j, k = (0, 1) if direction == 1 else (1, 0)

        # If we want to mark CDS regions, fetch them from the GTF-based data
        if with_cds:
            t_info = self.get_transcript_info(transcript_name)
            cds_start, cds_end = t_info['cds_start'], t_info['cds_end']
        else:
            cds_start = cds_end = None

        # Draw introns (lines between consecutive exons) with low zorder to ensure they are behind rectangles
        for i in range(len(exons) - 1):
            intron_start = cached_map(exons[i][j])
            intron_end   = cached_map(exons[i + 1][k])
            ax.plot([intron_start, intron_end],
                    [offset + 0.1, offset + 0.1],
                    color='black', linestyle='-', linewidth=1, zorder=0)

        # Draw exons as rectangles with UTR/CDS differentiation when CDS info is available.
        # The shapes remain as originally designed but the CDS segments are drawn with the base color.
        for idx, exon in enumerate(exons):
            exon_start_gen = exon[j]
            exon_end_gen   = exon[k]
            scaled_exon_start = cached_map(exon_start_gen)
            scaled_exon_end   = cached_map(exon_end_gen)
            width = scaled_exon_end - scaled_exon_start

            base_color = color
            base_edgecolor = 'black'

            if with_cds and (cds_start is not None) and (cds_end is not None):
                # Determine the true genomic bounds of the exon
                left_exon = min(exon_start_gen, exon_end_gen)
                right_exon = max(exon_start_gen, exon_end_gen)
                # Calculate the CDS overlap with the exon
                coding_left = max(left_exon, cds_start)
                coding_right = min(right_exon, cds_end)
                coding_exists = coding_left < coding_right

                if idx == 0 or idx == len(exons) - 1:
                    # For first and last exons, split into UTR and CDS portions if CDS is present
                    if coding_exists:
                        # Left UTR segment (if any)
                        if left_exon < coding_left:
                            scaled_utr_left = cached_map(left_exon)
                            scaled_utr_right = cached_map(coding_left)
                            utr_width = scaled_utr_right - scaled_utr_left
                            utr_height = height * 0.6
                            rect_utr = plt.Rectangle((scaled_utr_left, offset + (height - utr_height) / 2),
                                                     utr_width, utr_height,
                                                     fc=base_color, ec=base_edgecolor, zorder=1)
                            ax.add_patch(rect_utr)
                        # CDS segment with full height using the base color
                        scaled_cds_left = cached_map(coding_left)
                        scaled_cds_right = cached_map(coding_right)
                        cds_width = scaled_cds_right - scaled_cds_left
                        rect_cds = plt.Rectangle((scaled_cds_left, offset), cds_width, height,
                                                 fc=base_color, ec=base_edgecolor, zorder=1)
                        ax.add_patch(rect_cds)
                        # Right UTR segment (if any)
                        if coding_right < right_exon:
                            scaled_utr_left = cached_map(coding_right)
                            scaled_utr_right = cached_map(right_exon)
                            utr_width = scaled_utr_right - scaled_utr_left
                            utr_height = height * 0.6
                            rect_utr = plt.Rectangle((scaled_utr_left, offset + (height - utr_height) / 2),
                                                     utr_width, utr_height,
                                                     fc=base_color, ec=base_edgecolor, zorder=1)
                            ax.add_patch(rect_utr)
                    else:
                        # Entire exon is non-coding (UTR): draw as a smaller rectangle centered vertically
                        rect = plt.Rectangle((scaled_exon_start, offset + (height - height * 0.6) / 2),
                                             width, height * 0.6,
                                             fc=base_color, ec=base_edgecolor, zorder=1)
                        ax.add_patch(rect)
                    continue  # Skip further processing for first/last exon

                else:
                    # For middle exons, use full height if coding exists and reduced height otherwise,
                    # but always use the base color (removing the special CDS coloring).
                    if coding_exists:
                        rect = plt.Rectangle((scaled_exon_start, offset), width, height,
                                             fc=base_color, ec=base_edgecolor, zorder=1)
                    else:
                        rect = plt.Rectangle((scaled_exon_start, offset), width, height * 0.6,
                                             fc=base_color, ec=base_edgecolor, zorder=1)
                    ax.add_patch(rect)
                    continue
            else:
                # Without CDS information, draw the exon normally at full height.
                rect = plt.Rectangle((scaled_exon_start, offset), width, height,
                                     fc=base_color, ec=base_edgecolor, zorder=1)
                ax.add_patch(rect)

        # Draw an arrow to indicate transcript direction.
        arrow_y = offset - height/4
        if direction > 0:
            ax.arrow(0, arrow_y, 1, 0, width=0.0015,
                     head_length=0.01, head_width=0.1,
                     length_includes_head=True, overhang=1, color='black')
        else:
            ax.arrow(1, arrow_y, -1, 0, width=0.0015,
                     head_length=0.01, head_width=0.1,
                     length_includes_head=True, overhang=1, color='black')

        # Mark the transcript's genomic start/end in global coordinates.
        if direction == 1:
            real_start = exons[0][1]
            real_end   = exons[-1][0]
        else:
            real_start = exons[-1][1]
            real_end   = exons[0][0]

        scaled_real_start = cached_map(real_start)
        scaled_real_end   = cached_map(real_end)

        # Tick marks and labels at the transcript ends.
        ax.plot([scaled_real_start, scaled_real_start],
                [arrow_y - 0.03, arrow_y + 0.03], color='black')
        ax.plot([scaled_real_end, scaled_real_end],
                [arrow_y - 0.03, arrow_y + 0.03], color='black')

        ax.text(scaled_real_start, arrow_y - 0.06,
                str(real_start), ha='center', va='top', fontsize=9)
        ax.text(scaled_real_end, arrow_y - 0.06,
                str(real_end), ha='center', va='top', fontsize=9)

        # Transcript name at right edge.
        ax.text(1, offset - height,
                transcript_name, ha='right', va='top', fontsize=12)

    def _draw_transcripts_list(self, transcripts_ids, _ax, colors=None, draw_cds=False):
        """
        Draw multiple transcripts with the same global mapping,
        ensuring that exons sharing coordinates line up perfectly.
        """
        exons_list   = []
        directions   = []
        for tr in transcripts_ids:
            t, d = self._get_coord_from_tscrpt_id(tr)
            exons_list.append(t)
            directions.append(d)

        # Assign colors if none provided.
        if colors is None:
            colors = [self.colors[i % len(self.colors)] for i in range(len(exons_list))]

        # Build a single global mapping function from all transcripts' exons.
        mapping_fn = self._make_global_mapping(exons_list)

        # Reset plotting settings to avoid artifacts.
        plt.close('all')

        # Set up figure with x in [0..1] and y sized by the number of transcripts.
        plt.figure()
        plt.axes()
        plt.xlim(-0.05, 1.05)  # the mapping covers 0..1
        plt.ylim((0.1 - 0.5 * len(exons_list), 0.3))
        plt.margins(0.2)
        plt.axis('off')

        fig = plt.gcf()
        fig.set_size_inches(20, len(exons_list) * 2)

        # Draw each transcript in a separate 'row' (offset in the y direction).
        for i, (ex, di, co, tid) in enumerate(zip(exons_list, directions, colors, transcripts_ids)):
            offset = -0.5 * i
            self._draw_transcript(ex, di, co, tid, mapping_fn,
                                  offset=offset, with_cds=draw_cds)

        if _ax is None:
            plt.show()
        else:
            return plt

    def draw_transcripts_list(self, transcripts_ids, colors=None, draw_cds=False):
        """
        Public method to draw a list of transcripts with global intron scaling.
        (Note: draw_cds requires GTF-based transcript_data to highlight CDS regions.)
        """
        if draw_cds and self.transcript_data is None:
            raise Exception('A GTF file is necessary in order to display the CDS region')
        self._draw_transcripts_list(transcripts_ids, None, colors, draw_cds=draw_cds)

    def draw_transcripts_list_unscaled(self, transcripts_ids, colors=None):
        """
        For comparison: draw transcripts using exact genomic coordinates (no intron compression).
        """
        exons_list = []
        directions = []
        for tr in transcripts_ids:
            t, d = self._get_coord_from_tscrpt_id(tr)
            exons_list.append(t)
            directions.append(d)
        if colors is None:
            colors = [self.colors[i % len(self.colors)] for i in range(len(exons_list))]

        intervals = []
        for exon_list in exons_list:
            for e in exon_list:
                intervals.append([min(e[0], e[1]), max(e[0], e[1])])
        union_exons = merge_intervals(intervals)
        global_start = min(i[0] for i in union_exons)
        global_end   = max(i[1] for i in union_exons)

        # Linear mapping from genomic range to [0..1], no intron compression.
        def linear_mapping(x):
            return (x - global_start) / (global_end - global_start)

        # Reset plotting settings to avoid artifacts.
        plt.close('all')

        plt.figure()
        plt.axes()
        plt.xlim(-0.05, 1.05)
        plt.ylim((0.1 - 0.5 * len(exons_list), 0.3))
        plt.margins(0.2)
        plt.axis('off')
        fig = plt.gcf()
        fig.set_size_inches(20, len(exons_list) * 2)

        for i, (ex, di, co, name) in enumerate(zip(exons_list, directions, colors, transcripts_ids)):
            offset = -0.5 * i
            self._draw_transcript(ex, di, co, name, linear_mapping, offset=offset, with_cds=False)
        plt.show()

