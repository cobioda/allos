# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/007_preprocesing.ipynb.

# %% auto 0
__all__ = ['subset_common_cells', 'transfer_obs', 'get_sot_gene_matrix']

# %% ../nbs/007_preprocesing.ipynb 2
import scanpy as sc


def subset_common_cells( dataset1:sc.AnnData,  # First dataset to be subsetted.
                        dataset2:sc.AnnData   # Second dataset to compare with.
                        ) -> sc.AnnData:  # Subset of `dataset1` containing only cells also found in `dataset2`.
    
    "Subset `dataset1` to only include cells that are also present in `dataset2`."
    # Find common cells by intersecting the cell identifiers of both datasets
    common_cells = dataset1.obs_names.intersection(dataset2.obs_names)
    
    # Explicitly subset dataset1 to only include these common cells
    subset_dataset1 = dataset1[common_cells, :].copy()
    
    return subset_dataset1

# %% ../nbs/007_preprocesing.ipynb 3
import pandas as pd
import anndata as ad

#| export
def transfer_obs(dataset1: ad.AnnData,  # Source AnnData object with .obs metadata to transfer.
                 dataset2: ad.AnnData   # Target AnnData object to receive .obs metadata.
                 ) -> ad.AnnData:       # The modified `dataset2` with .obs from `dataset1` transferred.
    "Transfer `.obs` metadata from `dataset1` to `dataset2` one by one, while preserving the `.var` DataFrame of `dataset2`."
    
    # Ensure dataset2's .var is preserved without altering its contents
    var_dataset2 = dataset2.var.copy()
    
    # Clear current .obs in dataset2 to ensure it only contains metadata from dataset1
    dataset2.obs = pd.DataFrame(index=dataset2.obs.index)
    
    # Loop through each column in dataset1.obs and transfer it to dataset2.obs
    for column_name in dataset1.obs.columns:
        # Transfer each column individually
        dataset2.obs[column_name] = dataset1.obs[column_name].copy()

    # Reapply the saved .var to dataset2 to ensure it's preserved
    dataset2.var = var_dataset2

    return dataset2

# %% ../nbs/007_preprocesing.ipynb 4
import scanpy as sc
import numpy as np
import pandas as pd
from scipy.sparse import coo_matrix

def get_sot_gene_matrix(adata):
    """
    Construct a gene-level count matrix from transcript-level data.
    
    Parameters
    ----------
    adata : AnnData
        Input AnnData with transcript-level counts. Must have a column `geneId`
        in `adata.var` containing the gene ID for each transcript.
    
    Returns
    -------
    AnnData
        A new AnnData object where columns (var) represent unique genes, 
        and values are aggregated transcript counts.
    """
    # gene_ids must be something like adata.var['geneId']
    gene_ids = adata.var['geneId'].values
    
    # Find the unique gene IDs and map each transcript to one of these genes
    unique_gene_ids, inverse = np.unique(gene_ids, return_inverse=True)
    
    # Convert adata.X to a COO matrix (cheap if already sparse)
    X_coo = coo_matrix(adata.X)

    
    # Re-map the column indices: each old column index -> new gene index
    new_row = X_coo.row
    new_col = inverse[X_coo.col]
    new_data = X_coo.data
    
    # Build the new sparse matrix
    # (COO duplicates are summed when converting to CSR/CSC)
    new_coo = coo_matrix(
        (new_data, (new_row, new_col)),
        shape=(adata.n_obs, len(unique_gene_ids))
    )
    new_X = new_coo.tocsr()  # or .tocsc(), whichever you prefer
    
    # Build a new AnnData object at gene level
    adata_gene_level = sc.AnnData(
        X=new_X,
        obs=adata.obs.copy(),
        var=pd.DataFrame(index=unique_gene_ids)
    )

    adata_gene_level.var.index.names = ['geneId']

    
    return adata_gene_level

