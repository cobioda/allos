# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/008_visuals.ipynb.

# %% auto 0
__all__ = ['plot_transcripts', 'normal_reference_bandwidth', 'wkde2d', 'get_dens', 'calculate_density', 'plot_density',
           'plot_density_multi']

# %% ../nbs/008_visuals.ipynb 2
import numpy as np
import pandas as pd
import anndata as ad

# %% ../nbs/008_visuals.ipynb 9
import scanpy as sc

def plot_transcripts(adata, gene_id=None, transcripts=None):
    """
    Plot the UMAP with the specified transcripts or transcripts associated with the given gene ID.
    
    Parameters:
    -----------
    adata : AnnData
        The annotated data matrix.
    gene_id : str, optional
        The gene ID for which to find and plot associated transcripts. 
        Ignored if `transcripts` is provided.
    transcripts : list of str, optional
        A list of transcript IDs to plot. If provided, `gene_id` is ignored.
    
    Returns:
    --------
    None
        Displays the UMAP plot colored by the specified transcripts.
    """
    if transcripts is None:
        if gene_id is None:
            raise ValueError("Either `gene_id` or `transcripts` must be provided.")
        # Select transcripts associated with the provided gene ID
        transcripts = adata[:, adata.var['geneId'] == gene_id].var.index.to_list()
    
    # Plot UMAP
    sc.pl.umap(adata, color=transcripts)


# %% ../nbs/008_visuals.ipynb 12
import numpy as np
import pandas as pd
import scipy.sparse as sp
from scipy.stats import norm
import matplotlib.pyplot as plt

###############################################################################
# 1) Helper: approximate "hpi" bandwidth (1D) 
#    (Here we do a simple Silverman or similar rule-of-thumb, for demonstration)
###############################################################################

def normal_reference_bandwidth(x):
    """
    Approximate the normal-reference (Silverman's) bandwidth for 1D data.
    R's ks::hpi uses a more sophisticated pilot estimation, but this is
    often 'close enough' for large data.
    """
    x = np.asarray(x, dtype=float)
    n = len(x)
    iqr = np.subtract(*np.percentile(x, [75, 25]))
    sigma = np.std(x, ddof=1)
    # Silverman’s rule
    bw = 0.9 * min(sigma, iqr / 1.34) * n ** (-1 / 5)
    return bw


###############################################################################
# 2) The core wkde2d function 
#    (mirroring your R code's logic for x, y, w)
###############################################################################

def wkde2d(x, y, w=None, h=None, adjust=1.0, n=100, lims=None):
    """
    Python equivalent of your R 'wkde2d' function:
      x, y: coordinates (1D arrays) for each observation.
      w   : weight vector (same length as x, y).
      h   : tuple or scalar for bandwidth in the x/y directions (if None, use approximate).
      adjust: bandwidth adjustment scalar.
      n   : number of grid points in each direction.
      lims: [x_min, x_max, y_min, y_max] to define the grid.
    Returns a dict with {'x': gx, 'y': gy, 'z': Z}, analogous to R’s list(x=..., y=..., z=...).
    """
    x = np.asarray(x, dtype=float)
    y = np.asarray(y, dtype=float)

    if w is None:
        # If no weight vector given, assume uniform weights
        w = np.ones_like(x)
    else:
        w = np.asarray(w, dtype=float)

    if len(x) != len(y) or len(x) != len(w):
        raise ValueError("x, y, w must all have the same length")

    # Default lims: ranges of x,y
    if lims is None:
        lims = [x.min(), x.max(), y.min(), y.max()]
    if len(lims) != 4:
        raise ValueError("lims must be [x_min, x_max, y_min, y_max]")

    # If bandwidths not provided, estimate them
    if h is None:
        hx = normal_reference_bandwidth(x)
        hy = normal_reference_bandwidth(y)
        h = (hx, hy)
    else:
        # If user passes scalar, apply to both x and y
        if np.isscalar(h):
            h = (float(h), float(h))
        else:
            # Ensure is length-2
            h = tuple(h)
    # Apply the "adjust" factor
    h = (h[0] * adjust, h[1] * adjust)

    # Build the grid
    gx = np.linspace(lims[0], lims[1], n)
    gy = np.linspace(lims[2], lims[3], n)

    # Outer differences for x and y
    # shape: (n, len(x))
    ax = (gx[:, None] - x[None, :]) / h[0]
    ay = (gy[:, None] - y[None, :]) / h[1]

    # Compute normal pdf at each (grid, data) difference
    # norm.pdf(ax) is 1/sqrt(2π)*exp(-ax^2/2)
    # We'll just do it by hand for speed:
    fx = np.exp(-0.5 * ax**2) / np.sqrt(2.0 * np.pi)
    fy = np.exp(-0.5 * ay**2) / np.sqrt(2.0 * np.pi)

    # Multiply each data column by w
    w = w[None, :]  # shape => (1, len(x))
    fxw = fx * w
    fyw = fy * w

    # Now do the matrix multiplication: R’s tcrossprod(M1, M2) = M1 %*% t(M2)
    # shape => (n, n)
    z = fxw.dot(fyw.T)

    # Divide by sum of w, and the bandwidth product
    Z = z / (w.sum() * h[0] * h[1])

    return {"x": gx, "y": gy, "z": Z}


###############################################################################
# 3) Mapping per-cell densities via "findInterval"-like logic
###############################################################################

def get_dens(points, dens):
    """
    Map each 2D point to the approximate density in `dens["z"]`.
    This mimics the R code that uses findInterval.
       points: shape (n_cells, 2)
       dens  : dict with 'x', 'y', 'z', from wkde2d
    Returns a 1D np.array of densities (one per row in points).
    """
    xgrid = dens["x"]
    ygrid = dens["y"]
    Z     = dens["z"]  # shape => (len(xgrid), len(ygrid))

    # For each coordinate, find closest bin index.
    # np.searchsorted(xgrid, xp) finds where xp would be inserted;
    # subtract 1 so it behaves like R findInterval (the left bin).
    ix = np.searchsorted(xgrid, points[:, 0]) - 1
    iy = np.searchsorted(ygrid, points[:, 1]) - 1

    # Clamp to valid range
    ix = np.clip(ix, 0, len(xgrid) - 1)
    iy = np.clip(iy, 0, len(ygrid) - 1)

    return Z[ix, iy]


###############################################################################
# 4) Putting it all together in a mini "scanpy-like" usage:
###############################################################################

def calculate_density(adata, feature, basis="umap", adjust=1.0, map_to_cells=True):
    """
    1) Extract coordinates from adata.obsm[f"X_{basis}"].
    2) Extract expression vector for `feature`.
    3) Run the weighted KDE.
    4) If map_to_cells=True, return per-cell densities; else return the full grid.
    """
    # (a) get the 2D embedding:
    if f"X_{basis}" not in adata.obsm:
        raise ValueError(f"AnnData has no .obsm['X_{basis}']")

    coords = adata.obsm[f"X_{basis}"]  # shape => (n_cells, 2)
    if coords.shape[1] != 2:
        raise ValueError(f"Embedding {basis} must be 2D, found shape {coords.shape}")

    # (b) get weights w from the feature (assuming it's in adata.var_names)
    # or if it’s an obs-level feature, look in adata.obs:
    if feature in adata.var_names:
        # For gene expression, we can do:
        #   w = adata[:, feature].X.A1  if X is sparse 
        #   or  adata[:, feature].X if it’s dense
        #   or  adata.obs_vector(feature)
        # Below tries adata.obs_vector first:
        w = adata.obs_vector(feature)
    elif feature in adata.obs.columns:
        w = adata.obs[feature].values
    else:
        raise ValueError(f"Feature '{feature}' not found in adata.var_names or adata.obs.columns")

    # (c) compute the weighted 2D density:
    dens = wkde2d(
        x=coords[:, 0],
        y=coords[:, 1],
        w=w,
        adjust=adjust,
        n=200,         # or 100, your choice
        lims=None      # or specify [xmin, xmax, ymin, ymax]
    )

    # (d) either return the raw grid or map per-cell
    if map_to_cells:
        return get_dens(coords, dens)
    else:
        return dens


def plot_density(adata, feature, basis="umap", adjust=1.0, cmap="viridis"):
    """
    Simple scatterplot colored by the weighted density of `feature`.
    """
    # 1) Get per-cell densities
    z = calculate_density(adata, feature, basis=basis, adjust=adjust, map_to_cells=True)
    coords = adata.obsm[f"X_{basis}"]

    # 2) Plot
    plt.scatter(coords[:, 0], coords[:, 1], c=z, s=5, cmap=cmap)
    plt.title(f"Density: {feature}")
    plt.colorbar(label="Density")
    plt.xlabel(f"{basis}1")
    plt.ylabel(f"{basis}2")
    plt.tight_layout()
    plt.show()


# %% ../nbs/008_visuals.ipynb 14
import numpy as np
import matplotlib.pyplot as plt

def plot_density_multi(adata, features, basis="umap", adjust=1.0, cmap="viridis"):
    """
    Plot one or multiple features' density on the specified 2D embedding.
    - If 'features' is a single string, makes one subplot.
    - If 'features' is a list of strings, makes multiple side-by-side subplots.
    """
    # 1) Ensure we have a list
    if isinstance(features, str):
        features = [features]
    n_feats = len(features)

    # 2) Prepare subplots
    if n_feats == 0:
        raise ValueError("No features provided.")
    elif n_feats == 1:
        fig, ax_arr = plt.subplots(1, 1, figsize=(6, 5))
        ax_arr = [ax_arr]  # so we can iterate
    else:
        fig, ax_arr = plt.subplots(1, n_feats, figsize=(6 * n_feats, 5), 
                                   sharex=True, sharey=True)
    
    # 3) Extract the embedding
    if f"X_{basis}" not in adata.obsm:
        raise ValueError(f"AnnData has no .obsm['X_{basis}']")
    coords = adata.obsm[f"X_{basis}"]
    if coords.shape[1] != 2:
        raise ValueError(f"Embedding {basis} must be 2D, found shape {coords.shape}")

    # 4) For each feature, calculate density and plot
    for i, feat in enumerate(features):
        # calculate_density is the function you provided:
        z = calculate_density(adata, feat, basis=basis, adjust=adjust, map_to_cells=True)

        # scatter plot with density as color
        sc = ax_arr[i].scatter(coords[:, 0], coords[:, 1], c=z, s=5, cmap=cmap)
        ax_arr[i].set_title(f"Density: {feat}")
        ax_arr[i].set_xlabel(f"{basis}1")
        ax_arr[i].set_ylabel(f"{basis}2")

        cbar = plt.colorbar(sc, ax=ax_arr[i], fraction=0.046, pad=0.04)
        cbar.set_label("Density", rotation=90)

    plt.tight_layout()
    plt.show()
