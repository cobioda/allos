[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "allos",
    "section": "",
    "text": "pip install allos",
    "crumbs": []
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "allos",
    "section": "",
    "text": "pip install allos",
    "crumbs": []
  },
  {
    "objectID": "index.html#basic-workflow",
    "href": "index.html#basic-workflow",
    "title": "allos",
    "section": "Basic workflow",
    "text": "Basic workflow\n\nPlot transcript module\nPlot transcript module can be used on its own to explore the structure on known and especialy new transcripts. The long read sequencing methods are great to discovar new isoforms and it is often important to compare their structure with known isoforms. Transcript’s structure can be visualized with draw_transcript function from custom coordiantes or directly by indicating a valid Ensemble id.\n\nimport allos.transcript_plots as ptr\n\nMultiple transcripts can be vizualized on one panel with the function draw_transcripts_list where the transcripts’ ids are provided as a list. The list can be a mix of known and novev, custom defined transcripts:\n\nptr.TranscriptPlots.draw_transcripts_list([\"ENSMUST00000030636\", \"ENSMUST00000105867\", \"ENSMUST00000105868\", \"ENSMUST00000130253\", \"ENSMUST00000127279\"])\n\n\n\n\n\n\n\n\n\n\nGene report module\nOffers a complete pipeline to discover and visualize differentially expressed and switching isoforms among different cell types and conditions in long reads based single RNA-seq data. Allos supports several technologies and tools producing long reads based scRNA seq datasets: Oxford Nanopore, PacBio, Smartseq2 and such tools as Sicelore, Isocsceles, Kallisto etc. The output from other tools can be adapted to a universal reader.\n\nimport allos.gene_report as gr",
    "crumbs": []
  },
  {
    "objectID": "index.html#initialization",
    "href": "index.html#initialization",
    "title": "allos",
    "section": "1. Initialization",
    "text": "1. Initialization\nThe AnnDataIso object initializes with:\nInput: AnnData object and an optional cell types DataFrame. ### Setup: Filters genes with multiple isoforms. Calculates isoform percentages per gene for each cell type. Prepares the data for downstream analyses. ### Usage:\n\npath = al.readers_tests.download_test_data()\n\nFile downloaded successfully\nFile extracted successfully\n\n\n\nadata_iso = al.switch_search.create_iso_adata(path)\n\n\nadata_iso = al.anndata_iso.AnnDataIso(adata_iso)\n\n&lt;Figure size 100x100 with 0 Axes&gt;\n\n\n\nData Visualization\n\n\nIsoform Summary Method: plot_isoforms_summary() Purpose: Summarizes isoform switching and frequencies across genes. Subplots: Bar plot: Percentage of genes with multiple isoforms. Bar plot: Frequency of isoforms per gene. Boxplot: Number of genes expressed per cell type. Usage:\n\n\nGene-Specific Transcripts\nMethod: plot_transcripts_per_cell_type() Visualizes isoform expression across cell types for a specific gene. Parameters: gene_name: The gene to visualize. trs_to_show: List of transcript IDs to include (optional). Usage:\n\nadata_iso.plot_transcripts_per_cell_type(\"GeneName\")\n\n\n\nGene Summary\nMethod: draw_gene_summary() Purpose: Generates a comprehensive visualization of transcript counts, per-cell-type breakdown, and transcripts structures for a specific gene. Parameters: gene_name: Target gene for visualization. trs_to_show: List of transcripts to highlight. Usage:\n\nadata_iso.draw_gene_summary(\"GeneName\")",
    "crumbs": []
  },
  {
    "objectID": "index.html#statistical-analysis",
    "href": "index.html#statistical-analysis",
    "title": "allos",
    "section": "Statistical Analysis",
    "text": "Statistical Analysis\n\nFind Switching Isoforms Method: find_switching_isoforms() Purpose: Identifies genes with significant isoform switching between cell types using statistical tests. Parameters: cell_group_column: Column specifying cell group labels. min_count: Minimum expression count threshold. min_diff: Minimum expression difference for isoform detection. Usage:\n\n\nswitching_genes = adata_iso.find_switching_isoforms(cell_group_column=\"cell_type\")",
    "crumbs": []
  },
  {
    "objectID": "index.html#likelihood-ratio-test",
    "href": "index.html#likelihood-ratio-test",
    "title": "allos",
    "section": "Likelihood Ratio Test",
    "text": "Likelihood Ratio Test\nMethod: __compare_groups() Purpose: Tests for significant isoform usage differences between two groups. Parameters: group_1_label and group_2_label: Names of the groups to compare. cell_group_column: Column specifying cell group labels. gene_id: Gene ID to test.\n\nadata_iso.plot_isoforms_summary()\n\n\nGene-Specific Transcripts\nMethod: plot_transcripts_per_cell_type() Visualizes isoform expression across cell types for a specific gene. Parameters: gene_name: The gene to visualize. trs_to_show: List of transcript IDs to include (optional). Usage:\n\nadata_iso.plot_transcripts_per_cell_type(\"GeneName\")\n\n\n\nGene Summary\nMethod: draw_gene_summary() Purpose: Generates a comprehensive visualization of transcript counts, per-cell-type breakdown, and transcripts structures for a specific gene. Parameters: gene_name: Target gene for visualization. trs_to_show: List of transcripts to highlight. Usage:\n\nadata_iso.draw_gene_summary(\"GeneName\")",
    "crumbs": []
  },
  {
    "objectID": "index.html#statistical-analysis-1",
    "href": "index.html#statistical-analysis-1",
    "title": "allos",
    "section": "Statistical Analysis",
    "text": "Statistical Analysis\n\nFind Switching Isoforms Method: find_switching_isoforms() Purpose: Identifies genes with significant isoform switching between cell types using statistical tests. Parameters: cell_group_column: Column specifying cell group labels. min_count: Minimum expression count threshold. min_diff: Minimum expression difference for isoform detection. Usage:\n\n\nswitching_genes = adata_iso.find_switching_isoforms(cell_group_column=\"cell_type\")",
    "crumbs": []
  },
  {
    "objectID": "index.html#likelihood-ratio-test-1",
    "href": "index.html#likelihood-ratio-test-1",
    "title": "allos",
    "section": "Likelihood Ratio Test",
    "text": "Likelihood Ratio Test\nMethod: __compare_groups() Purpose: Tests for significant isoform usage differences between two groups. Parameters: group_1_label and group_2_label: Names of the groups to compare. cell_group_column: Column specifying cell group labels. gene_id: Gene ID to test.\n\nadata_iso.plot_isoforms_summary()\n\n\nGene-Specific Transcripts\nMethod: plot_transcripts_per_cell_type() Visualizes isoform expression across cell types for a specific gene. Parameters: gene_name: The gene to visualize. trs_to_show: List of transcript IDs to include (optional). Usage:\n\nadata_iso.plot_transcripts_per_cell_type(\"GeneName\")\n\n\n\nGene Summary\nMethod: draw_gene_summary() Purpose: Generates a comprehensive visualization of transcript counts, per-cell-type breakdown, and transcripts structures for a specific gene. Parameters: gene_name: Target gene for visualization. trs_to_show: List of transcripts to highlight. Usage:\n\nadata_iso.draw_gene_summary(\"GeneName\")",
    "crumbs": []
  },
  {
    "objectID": "index.html#statistical-analysis-2",
    "href": "index.html#statistical-analysis-2",
    "title": "allos",
    "section": "Statistical Analysis",
    "text": "Statistical Analysis\n\nFind Switching Isoforms Method: find_switching_isoforms() Purpose: Identifies genes with significant isoform switching between cell types using statistical tests. Parameters: cell_group_column: Column specifying cell group labels. min_count: Minimum expression count threshold. min_diff: Minimum expression difference for isoform detection. Usage:\n\n\nswitching_genes = adata_iso.find_switching_isoforms(cell_group_column=\"cell_type\")",
    "crumbs": []
  },
  {
    "objectID": "index.html#likelihood-ratio-test-2",
    "href": "index.html#likelihood-ratio-test-2",
    "title": "allos",
    "section": "Likelihood Ratio Test",
    "text": "Likelihood Ratio Test\nMethod: __compare_groups() Purpose: Tests for significant isoform usage differences between two groups. Parameters: group_1_label and group_2_label: Names of the groups to compare. cell_group_column: Column specifying cell group labels. gene_id: Gene ID to test.",
    "crumbs": []
  },
  {
    "objectID": "index.html#isoform-rating",
    "href": "index.html#isoform-rating",
    "title": "allos",
    "section": "Isoform Rating",
    "text": "Isoform Rating\nMajor vs. Minor Isoforms Method: find_major_minor_isoforms() Purpose: Identifies major and minor isoforms for each gene across cell types. Usage:\n\nmajor_isoforms = adata_iso.find_major_minor_isoforms()",
    "crumbs": []
  },
  {
    "objectID": "006_gene_report.html",
    "href": "006_gene_report.html",
    "title": "allos",
    "section": "",
    "text": "class GeneReports(TranscriptPlots, AnnDataIso):\n    def __init__(self, anndata: ad.AnnData, cell_types: pd.DataFrame, palette='ghibli', gtf_file=None, reference_fasta=None):\n        AnnDataIso.__init__(self,anndata, cell_types, palette)\n        TranscriptPlots.__init__(self,gtf_file, reference_fasta)\n\n    # Plotting a summary of isoform-related metrics.\n    def plot_isoforms_summary(self):\n        \"\"\"\n        Generates a combined plot summarizing:\n        1. Percentage of genes with multiple isoforms.\n        2. Frequency distribution of isoforms per gene.\n        3. Number of genes expressed per cell type.\n\n        Returns:\n        - Combined plot saved as an image.\n        \"\"\"\n        ax1 = pw.Brick(figsize=(4, 4))\n        self._plot_switch_gen_bar(ax1)\n        ax1.set_title(\"Multiple isoforms genes %\")\n        ax2 = pw.Brick(figsize=(4, 4))\n        self._plot_isoforms_frequencies(ax2)\n        ax2.set_title(\"Frequency of isoforms per gene\")\n        ax3 = pw.Brick(figsize=(3, 2))\n        self._plot_genes_cell_type(ax3)\n        ax3.set_title(\"Nb of genes per cell type\")\n        return (ax1 | ax2 | ax3).savefig()\n\n    # Private method to create a boxplot of genes expressed per cell type.\n    def _plot_genes_cell_type(self, _ax):\n        \"\"\"\n        Plots the number of genes expressed per cell type as a boxplot.\n\n        Parameters:\n        - _ax (Axes): Matplotlib axes to render the plot.\n        \"\"\"\n        if _ax is None:\n            df = pd.DataFrame(np.transpose(self.X), columns=self.obs['cell_type'])\n            df = df.sum(axis=0).to_frame().reset_index()\n            df.columns = ['cell_type', 'n_of_genes']\n            ax = sns.boxplot(x='cell_type', y='n_of_genes', data=df)\n            ax1 = sns.stripplot(x='cell_type', y='n_of_genes', data=df, color='black', size=3)\n            ax.set_xticklabels(ax.get_xticklabels(), rotation=90)\n            plt.show()\n        else:\n            df = pd.DataFrame(np.transpose(self.X), columns=self.obs['cell_type'])\n            df = df.sum(axis=0).to_frame().reset_index()\n            df.columns = ['cell_type', 'n_of_genes']\n            sns.boxplot(x='cell_type', y='n_of_genes', data=df, ax=_ax)\n            sns.stripplot(x='cell_type', y='n_of_genes', data=df, color='black', size=3, ax=_ax)\n            _ax.set_xticklabels(_ax.get_xticklabels(), rotation=90)\n\n    def plot_genes_cell_type(self):\n        \"\"\"\n        Public method to plot the number of genes expressed per cell type.\n        \"\"\"\n        self._plot_genes_cell_type(None)\n\n    # Method to visualize isoform frequency distribution.\n    def _plot_isoforms_frequencies(self, _ax):\n        \"\"\"\n        Plots the frequency distribution of isoforms per gene.\n\n        Parameters:\n        - _ax (Axes): Matplotlib axes to render the plot.\n        \"\"\"\n        if _ax is None:\n            fig, ax = plt.subplots()\n            self.gene_counts['transcriptId'].value_counts().plot(\n                ax=ax, kind='bar', xlabel='number of isoforms per gene', ylabel='quantity of genes'\n            )\n        else:\n            self.gene_counts['transcriptId'].value_counts().plot(\n                ax=_ax, kind='bar', xlabel='number of isoforms per gene', ylabel='quantity of genes'\n            )\n\n    def plot_isoforms_frequencies(self):\n        \"\"\"\n        Public method to plot the frequency distribution of isoforms per gene.\n        \"\"\"\n        self._plot_isoforms_frequencies(None)\n\n    def plot_switch_gen_bar (self, _ax):\n        self._plot_switch_gen_bar(None)\n\n    def _plot_switch_gen_bar (self, _ax):\n        if _ax is None:\n            iso_per_gene = self.gene_counts\n            x = ['genes']\n            x1 = ['transcripts']\n            multiple_iso = sum(iso_per_gene['transcriptId'] &gt; 1)\n            mono_iso = sum((iso_per_gene['transcriptId'] &gt; 1) == False)\n            labels = [str(round(1000*multiple_iso/(multiple_iso+mono_iso))/10) + '%', str(round(1000*mono_iso/(multiple_iso+mono_iso))/10) + '%']\n            fig, ax = plt.subplots()\n            mult = ax.bar(x, multiple_iso, label=labels[1], color=self.colors[0]) #multiple_iso/(multiple_iso+mono_iso))\n            mono = ax.bar(x, mono_iso, bottom=multiple_iso, label=labels[0], color=self.colors[0]) #mona_iso/(multiple_iso+mono_iso))\n            tran = ax.bar(x1, len(self.var['transcriptId']), color=self.colors[2])\n            ax.text(\n                ax.patches[0].get_x() + ax.patches[0].get_width() / 2, ax.patches[0].get_height() / 2, labels[0], ha=\"center\", va=\"center\"\n                )\n            ax.text(\n                ax.patches[1].get_x() + ax.patches[1].get_width() / 2, ax.patches[1].get_height() / 2 + ax.patches[0].get_height(), labels[1], ha=\"center\", va=\"center\"\n                )\n            plt.legend(['Multiple isoforms', 'Single isoform'])\n            plt.show()\n        else:\n            iso_per_gene = self.gene_counts\n            x = ['genes']\n            x1 = ['transcripts']\n            multiple_iso = sum(iso_per_gene['transcriptId'] &gt; 1)\n            mono_iso = sum((iso_per_gene['transcriptId'] &gt; 1) == False)\n            labels = [str(round(1000*multiple_iso/(multiple_iso+mono_iso))/10) + '%', str(round(1000*mono_iso/(multiple_iso+mono_iso))/10) + '%']\n            mult = _ax.bar(x, multiple_iso, label=labels[1], color=self.colors[0]) #multiple_iso/(multiple_iso+mono_iso))\n            mono = _ax.bar(x, mono_iso, bottom=multiple_iso, label=labels[0], color=self.colors[1]) #mona_iso/(multiple_iso+mono_iso))\n            tran = _ax.bar(x1, len(self.var['transcriptId']), color=self.colors[2])\n            _ax.text(\n                _ax.patches[0].get_x() + _ax.patches[0].get_width() / 2, _ax.patches[0].get_height() / 2, labels[0], ha=\"center\", va=\"center\"\n                )\n            _ax.text(\n                _ax.patches[1].get_x() + _ax.patches[1].get_width() / 2, _ax.patches[1].get_height() / 2 + _ax.patches[0].get_height(), labels[1], ha=\"center\", va=\"center\"\n                )\n            _ax.legend(['Multiple isoforms', 'Single isoform'])\n            plt.show()\n\n    def _trsct_counts_cell_type (self, gene_name, trs_to_show, _ax):\n        if _ax is None:\n        # create df with filtered isoform counts and labeled cell types:\n            df = self._filtered_anndata.to_df().set_index(self._filtered_anndata.obs['cell_type'])\n            df = df.transpose()\n            df[['transcriptId', 'geneId']] = self._filtered_anndata.var[['transcriptId', 'geneId']]\n            gene_iso_count = df[df['geneId'] == gene_name]\n            gene_iso_count = gene_iso_count.drop('geneId', axis=1).set_index('transcriptId').transpose()\n            gene_iso_count_long = gene_iso_count.reset_index().melt(id_vars='cell_type', var_name='transcriptId', value_name='count')\n            if trs_to_show != []:\n                gene_iso_count_long = gene_iso_count_long[gene_iso_count_long['transcriptId'].isin(trs_to_show)]\n            g = sns.catplot(x=\"cell_type\", y=\"count\", col=\"transcriptId\", aspect=1, dodge=False, kind=\"violin\", data=gene_iso_count_long, palette=self.colors)\n            # Set custom facet titles\n            g.set_titles(col_template=\"{col_name}\", size = 8)\n            # Remove x ticks\n            g.set_xticklabels(rotation=90)\n            g.fig.suptitle(gene_name)\n            plt.show()\n        else:\n            df = self._filtered_anndata.to_df ().set_index(self._filtered_anndata.obs['cell_type'])\n            df = df.transpose()\n            df[['transcriptId', 'geneId']] = self._filtered_anndata.var[['transcriptId', 'geneId']]\n            gene_iso_count = df[df['geneId']== gene_name]\n            gene_iso_count = gene_iso_count.drop('geneId', axis=1).set_index('transcriptId').transpose()\n            gene_iso_count_long = gene_iso_count.reset_index().melt(id_vars='cell_type', var_name='transcriptId', value_name='count')\n            if trs_to_show != []:\n                gene_iso_count_long = gene_iso_count_long[gene_iso_count_long['transcriptId'].isin(trs_to_show)]\n            g = sns.catplot(x=\"cell_type\", y=\"count\", col=\"transcriptId\", aspect=1, dodge=False, kind=\"violin\", data=gene_iso_count_long, palette=self.colors)\n            # Set custom facet titles\n            g.set_titles(col_template=\"{col_name}\", size = 8)\n            # Remove x ticks\n            g.set_xticklabels(rotation=90, labels=self.obs['cell_type'].unique())\n            g.fig.suptitle(gene_name)\n            return g\n\n    def trsct_counts_cell_type (self, gene_name, trs_to_show = []):\n        # create df with filtered isoform counts and labeled cell types:\n        self._trsct_counts_cell_type(gene_name, trs_to_show, None)\n\n    def _plot_transcripts_per_cell_type(self, gene_name, trs_to_show, _ax):\n        if trs_to_show == []:\n            transcripts_id = self._get_transcripts_from_gene(gene_name)\n        else:\n            transcripts_id = trs_to_show\n        if _ax is None:\n            fig, ax = plt.subplots()\n            grouped = self._filtered_anndata.obsm['Iso_prct']\n            grouped['cell_type'] = self.obs['cell_type']\n            res = grouped.groupby('cell_type').mean().transpose()\n            res = res.assign(transcriptId=self._filtered_anndata.var['transcriptId'].to_list())\n            res = res.assign(geneId=self._filtered_anndata.var['geneId'].to_list())\n            res = res[res['geneId'] == gene_name].drop(['geneId'], axis=1)\n            res = res[res['transcriptId'].isin(transcripts_id)]\n            plot_data = res.set_index('transcriptId').transpose()\n            plot_data.plot(kind='barh', ax=ax, stacked=True, color=self.colors).legend(loc='center left',bbox_to_anchor=(1.0, 1.0))\n            plt.legend(self.get_transcripts_common_names(transcripts_id), loc=\"upper left\", bbox_to_anchor=(1, 1))\n            #plt.legend(self.get_transcripts_common_names(trs_to_show))\n            plt.ylabel('Cell type')\n        else:\n            grouped = self._filtered_anndata.obsm['Iso_prct']\n            grouped['cell_type'] = self.obs['cell_type']\n            res = grouped.groupby('cell_type').mean().transpose()\n            res = res.assign(transcriptId=self._filtered_anndata.var['transcriptId'].to_list())\n            res = res.assign(geneId=self._filtered_anndata.var['geneId'].to_list())\n            res = res[res['geneId'] == gene_name].drop(['geneId'], axis=1)\n            res = res[res['transcriptId'].isin(transcripts_id)]\n            plot_data = res.set_index('transcriptId').transpose()\n            plot_data.plot(kind='barh', stacked=True, ax=_ax, color=self.colors).legend(loc='center left',bbox_to_anchor=(1.0, 1.0))\n\n    def plot_transcripts_per_cell_type(self, gene_name, trs_to_show = []):\n        self._plot_transcripts_per_cell_type(gene_name, trs_to_show, None)\n\n    def _get_transcripts_from_gene(self, gene_name):\n        elems = self._filtered_anndata.var\n        return elems[elems['geneId'] == gene_name]['transcriptId'].to_list()\n\n    def _draw_transcripts_list_from_gene(self, gene_name, trs_to_show, _ax, colors=None):\n        if trs_to_show == []:\n            transcripts_id = self._get_transcripts_from_gene(gene_name)\n        else:\n            transcripts_id = trs_to_show\n        exons = []\n        directions = []\n        for tr in transcripts_id:\n            t, d = self._get_coord_from_tscrpt_id(tr)\n            exons += [t]\n            directions += [d]\n        if colors is None:\n            colors = []\n            for i in range(len(exons)):\n                colors.append(self.colors[i % len(self.colors)])\n        def get_limits(ex, dir):\n            start = sys.maxsize\n            end = -sys.maxsize\n            for (e, d) in zip(ex, dir):\n                if d == 1:\n                    start = min(start,e[0][1])\n                    end = max(end, e[-1][0])\n                else:\n                    start = min(start,e[-1][1])\n                    end = max(end, e[0][0])\n            return (start, end)\n        plt.axes()\n        plt.xlim((-0.1, 1.1))\n        plt.ylim((0.1 - 0.5 *  len(exons), 0.3))\n        plt.margins(0.2)\n        plt.axis('off')\n        fig = plt.gcf()\n        fig.set_size_inches(20, len(exons) * 2)\n        i = 0\n        (start, end) = get_limits(exons, directions)\n        for (ex, di, co, name) in zip(exons, directions, colors, transcripts_id):\n            self._draw_transcript(ex, di, co, name, offset= -0.5 * i, start_override=start, end_override=end, no_render=True)\n            i+=1\n        if _ax is None:\n            plt.show()\n        else:\n            return plt\n\n    def draw_transcripts_list_from_gene(self, gene_name, colors=None):\n        self._draw_transcripts_list_from_gene(gene_name, [], None, colors)\n\n    def draw_gene_summary(self, gene_name, trs_to_show = []):\n        ax1 = pw.Brick(figsize=(12,4))\n        pw.overwrite_axisgrid()\n        fg = self._trsct_counts_cell_type(gene_name, trs_to_show, ax1)\n        ax4 = pw.load_seaborngrid(fg)\n        ax1.set_title(\"Transcripts count per cell type\")\n        ax2 = pw.Brick(figsize=(12,4))\n        self._plot_transcripts_per_cell_type(gene_name, trs_to_show, ax2)\n        ax2.set_title(\"Transcripts count per cell type\")\n        ax3 = pw.Brick(figsize=(12,4))\n        self._draw_transcripts_list_from_gene(gene_name, trs_to_show, ax3)\n        ax3.set_title(\"Transcripts list\")\n        return (ax4/(ax2/ax3)).savefig()\n\n    # More detailed functions omitted for brevity.",
    "crumbs": [
      "006_gene_report.html"
    ]
  },
  {
    "objectID": "004_anndata_iso.html",
    "href": "004_anndata_iso.html",
    "title": "allos",
    "section": "",
    "text": "C:\\Users\\Anna\\PycharmProjects\\allos\\.venv\\Lib\\site-packages\\fastcore\\docscrape.py:230: UserWarning: Unknown section See Also\n  else: warn(msg)\n\nsource\n\nAnnDataIso\n\n AnnDataIso (anndata:anndata._core.anndata.AnnData,\n             cell_types:pandas.core.frame.DataFrame, palette='ghibli')\n\n*An annotated data matrix.\n.. figure:: ../_static/img/anndata_schema.svg :width: 260px :align: right :class: dark-light\n:class:~anndata.AnnData stores a data matrix :attr:X together with annotations of observations :attr:obs (:attr:obsm, :attr:obsp), variables :attr:var (:attr:varm, :attr:varp), and unstructured annotations :attr:uns.\nAn :class:~anndata.AnnData object adata can be sliced like a :class:~pandas.DataFrame, for instance adata_subset = adata[:, list_of_variable_names]. :class:~anndata.AnnData’s basic structure is similar to R’s ExpressionSet [Huber15]_. If setting an .h5ad-formatted HDF5 backing file .filename, data remains on the disk but is automatically loaded into memory if needed.*",
    "crumbs": [
      "004_anndata_iso.html"
    ]
  },
  {
    "objectID": "002_transcript_data.html",
    "href": "002_transcript_data.html",
    "title": "allos",
    "section": "",
    "text": "source\n\nTranscriptData\n\n TranscriptData (gtf_file:str, reference_fasta:Optional[str]=None)\n\n*A class for managing transcript and gene information from a GTF file using PyRanges.\nExisting Features: - Lookup by transcript ID or gene ID/name - Support for exons, CDS, UTR queries - Intron coordinate calculation - Batch queries - Transcript length calculation - Caching/memoization for repeated queries - Basic logging/error handling\nNEW Features: (1) Nucleotide/protein sequence retrieval for CDS (with optional FASTA) (2) Alternative splicing analysis with splice junctions, isoform comparisons, and junction-chain interpretation.*",
    "crumbs": [
      "002_transcript_data.html"
    ]
  },
  {
    "objectID": "palettes.html",
    "href": "palettes.html",
    "title": "Palettes",
    "section": "",
    "text": "import seaborn as sns\nimport matplotlib.pyplot as plt\n# Display the color palette\nsns.palplot(synthwave)\nplt.show()\n\n\n\n\n\n\n\n\n\nsns.palplot(ghibli)\nplt.show()",
    "crumbs": [
      "Palettes"
    ]
  },
  {
    "objectID": "transcript_plots.html",
    "href": "transcript_plots.html",
    "title": "Transcript plots",
    "section": "",
    "text": "from allos.transcript_data import TranscriptData\n\n\nimport os\nimport urllib.request\nfrom pathlib import Path\n\n\n# Example Ensembl URLs for mouse GRCm39 (release 109)\ngtf_url = \"ftp://ftp.ensembl.org/pub/release-109/gtf/mus_musculus/Mus_musculus.GRCm39.109.gtf.gz\"\n#fasta_url = \"ftp://ftp.ensembl.org/pub/release-109/fasta/mus_musculus/dna/Mus_musculus.GRCm39.dna.primary_assembly.fa.gz\"\n\ndata_dir = Path(\"data\")\ndata_dir.mkdir(exist_ok=True)\n\ngtf_file_local = data_dir / \"Mus_musculus.GRCm39.109.gtf.gz\"\nfasta_file_local = data_dir / \"Mus_musculus.GRCm39.dna.primary_assembly.fa.gz\"\n\n# Download if not already present\nif not gtf_file_local.is_file():\n    print(f\"Downloading {gtf_url}...\")\n    urllib.request.urlretrieve(gtf_url, gtf_file_local)\n\n#if not fasta_file_local.is_file():\n    #print(f\"Downloading {fasta_url}...\")\n    #urllib.request.urlretrieve(fasta_url, fasta_file_local)\n\n# Instantiate your TranscriptData\ntd = TranscriptData(\n    gtf_file=gtf_file_local,\n    reference_fasta=fasta_file_local\n)\n\n# Now you can make queries like:\nexample_transcript_id = \"ENSMUST00000070533\"  # e.g., for mouse\nexons = td.get_exons(example_transcript_id)\nprint(\"Exons:\", exons)\n\nExons: +--------------+----------------+------------+-----------+-------+\n|   Chromosome | Source         | Feature    |     Start | +22   |\n|   (category) | (object)       | (object)   |   (int64) | ...   |\n|--------------+----------------+------------+-----------+-------|\n|            1 | ensembl_havana | exon       |   3740774 | ...   |\n|            1 | ensembl_havana | exon       |   3491924 | ...   |\n|            1 | ensembl_havana | exon       |   3284704 | ...   |\n+--------------+----------------+------------+-----------+-------+\nStranded PyRanges object has 3 rows and 26 columns from 1 chromosomes.\nFor printing, the PyRanges was sorted on Chromosome and Strand.\n22 hidden columns: End, Score, Strand, Frame, gene_id, gene_version, ... (+ 16 more.)\n\n\n\nsource\n\nTranscriptPlots\n\n TranscriptPlots (gtf_file=None, reference_fasta=None)\n\nInitialize self. See help(type(self)) for accurate signature.\nTo initialise class:\n\ntp = TranscriptPlots(gtf_file_local)\n\nTo plot a panel for one or several transcripts:\n\ntp.draw_transcripts_list([\"ENSMUST00000107851\", \"ENSMUST00000107846\", \"ENSMUST00000107847\"], colors=ghibli)\n\n\n\n\n\n\n\n\nTo retrieve information about a transcript of interest:\n\ntp.get_transcript_info(\"ENSMUST00000107847\")\n\n{'transcript_id': 'ENSMUST00000107847',\n 'transcript_name': 'Clta-203',\n 'transcript_type': 'unknown',\n 'cds_start': 44012791,\n 'cds_end': 44032400,\n 'chromosome': '4',\n 'strand': '+'}\n\n\n“draw_transcript_list_unscaled” keeps the structure of transcripts but shortens the introns. It is useful to compare the structure of transcipts with extremely long introns:\n\ntp.draw_transcripts_list_unscaled([\"ENSMUST00000107851\", \"ENSMUST00000107846\", \"ENSMUST00000107847\"], colors=ghibli)\n\n\n\n\n\n\n\n\nIf neither gtf nor fasta is provided, the transcripts can be provided as ensembl id and the coordinates will be fetched from ensembl api.",
    "crumbs": [
      "Transcript plots"
    ]
  },
  {
    "objectID": "003_readers_tests.html",
    "href": "003_readers_tests.html",
    "title": "allos",
    "section": "",
    "text": "def download_test_data(url: str = \"https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM3748nnn/GSM3748087/suppl/GSM3748087%5F190c.isoforms.matrix.txt.gz\") -&gt; str:\n    \"\"\"\n    Downloads a test data file from a specified URL, saves it locally, and extracts it.\n\n    Parameters:\n    url (str): The URL of the file to be downloaded. Defaults to a pre-defined test dataset.\n\n    Returns:\n    str: The absolute path of the extracted file if the download is successful, or None if it fails.\n    \"\"\"\n    print(f\"Starting download of test data from {url}\")\n\n    # Extract filename from the URL\n    filename = url.split('/')[-1]\n    compressed_file = filename\n\n    # Generate a unique filename for the extracted file\n    base_extracted_file = \"sample_isomatrix\"\n    counter = 1\n    extracted_file = f\"{base_extracted_file}.txt\"\n    while os.path.exists(extracted_file):\n        extracted_file = f\"{base_extracted_file}_{counter}.txt\"\n        counter += 1\n\n    # Download the file from the given URL\n    try:\n        urllib.request.urlretrieve(url, compressed_file)\n        print(\"File downloaded successfully\")\n    except Exception as e:\n        print(f\"Failed to download the file: {e}\")\n        return None\n\n    # Extract the file\n    try:\n        with gzip.open(compressed_file, 'rb') as f_in:\n            with open(extracted_file, 'wb') as f_out:\n                shutil.copyfileobj(f_in, f_out)\n        print(\"File extracted successfully\")\n        return os.path.abspath(extracted_file)\n    except Exception as e:\n        print(f\"Failed to extract the file: {e}\")\n        return None\n    finally:\n        # Clean up the compressed file\n        if os.path.exists(compressed_file):\n            os.remove(compressed_file)\n\n#| export\nimport os\nimport pandas as pd\nimport scanpy as sc\nfrom anndata import AnnData\n\ndef iso_concat(data_inputs, batch_info=None, batch_type='path'):\n    \"\"\"\n    Concatenates a list of AnnData objects or paths to AnnData objects based on the union of transcriptIds,\n    while preserving geneId information which might be non-unique per transcriptId.\n    Missing values are filled with zeros. Adds a batch column to `.obs` based on the file path, obs_names, or numeric.\n\n    Parameters:\n    data_inputs (list of str or AnnData):\n        List of paths to AnnData objects or AnnData objects to concatenate.\n    batch_info (list of str, optional):\n        List of batch identifiers for each AnnData object in data_inputs.\n        If not provided, batch identifiers are extracted from file paths, obs_names, or a numeric sequence.\n    batch_type (str, optional):\n        Specifies which type of batch information to use. One of ['path', 'obs_names', 'numeric'].\n        Defaults to 'path'.\n\n    Returns:\n    AnnData:\n        A single concatenated AnnData object with harmonized features, geneId annotations, and batch info.\n    \"\"\"\n    adata_list = []\n    df_list = []\n    gene_ids = {}\n    batch_info_list = []\n\n    for i, data_input in enumerate(data_inputs):\n        # Check if the input is a path (string) or an AnnData object\n        if isinstance(data_input, str):\n            adata = sc.read_h5ad(data_input)\n            # Determine batch label based on batch_type\n            if batch_type == 'path':\n                batch = os.path.basename(data_input).split('_isomatrix')[0] if batch_info is None else batch_info[i]\n            elif batch_type == 'obs_names':\n                batch = adata.obs_names[0] if batch_info is None else batch_info[i]\n            elif batch_type == 'numeric':\n                batch = str(i)\n            else:\n                raise ValueError(\"batch_type should be 'path', 'obs_names' or 'numeric'.\")\n        elif isinstance(data_input, AnnData):\n            adata = data_input\n            # Determine batch label when input is already an AnnData object\n            if batch_type == 'obs_names':\n                batch = adata.obs_names[0] if batch_info is None else batch_info[i]\n            elif batch_type == 'numeric':\n                batch = str(i)\n            else:\n                raise ValueError(\"batch_type should be 'obs_names' or 'numeric' when passing AnnData objects.\")\n        else:\n            raise ValueError(\"data_inputs must be a list of paths to AnnData objects or AnnData objects.\")\n\n        adata_list.append(adata)\n        # Convert adata.X to a DataFrame for outer-join concatenation\n        df = pd.DataFrame(adata.X.T, index=adata.var['transcriptId'], columns=adata.obs_names)\n        df_list.append(df)\n        batch_info_list.extend([batch] * adata.n_obs)\n\n        # Map transcriptId to its geneId\n        for transcript_id, gene_id in zip(adata.var['transcriptId'], adata.var['geneId']):\n            gene_ids[transcript_id] = gene_id\n\n    # Perform an outer join on all DataFrames\n    concat_df = pd.concat(df_list, axis=1, join='outer').fillna(0)\n\n    # Create a new var DataFrame with geneIds mapped from transcriptIds\n    var_df = pd.DataFrame(index=concat_df.index)\n    var_df['geneId'] = pd.Series(gene_ids).reindex(concat_df.index)\n\n    # Build an AnnData object, transposing so obs are rows\n    concatenated_adata = sc.AnnData(X=concat_df.T, var=var_df)\n\n    # Add batch info to obs\n    concatenated_adata.obs['batch'] = batch_info_list\n\n    return concatenated_adata\n\n\nsource\n\nread_sicelore_isomatrix\n\n read_sicelore_isomatrix (file_path:str, gene_id_label:str='geneId',\n                          transcript_id_label:str='transcriptId',\n                          remove_undef:bool=True, sparse:bool=False)\n\nRead a SiCeLoRe isomatrix file (tab-delimited) and convert it into a scanpy-compatible AnnData object.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfile_path\nstr\n\nPath to the isomatrix file (tab-delimited).\n\n\ngene_id_label\nstr\ngeneId\nRow/column label used for gene IDs (default “geneId”).\n\n\ntranscript_id_label\nstr\ntranscriptId\nRow/column label used for transcript IDs (default “transcriptId”).\n\n\nremove_undef\nbool\nTrue\nWhether to remove rows with transcriptId=“undef” (default True).\n\n\nsparse\nbool\nFalse\nWhether to store the matrix in sparse format (default False).\n\n\nReturns\nAnnData\n\nAn AnnData object containing numeric data in .X and metadata in .var.\n\n\n\n\ndef run_tests():\n    df = pd.read_csv('/data/analysis/data_mcandrew/e18.mouse.clusters.csv')\n    df['barcode'] = df.index.str.split('_').str[1]\n\n\n    mouse_data_str_1 = download_test_data()\n    print(\"Test data downloaded successfully\")\n\n\n    mouse_data_str_2 = download_test_data(\"https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM3748nnn/GSM3748089/suppl/GSM3748089%5F951c.isoforms.matrix.txt.gz\")\n    print(\"Test data downloaded successfully\")\n\n\n    mouse_1 = read_sicelore_isomatrix(file_path=mouse_data_str_1)\n    mouse_2 = read_sicelore_isomatrix(file_path=mouse_data_str_2)\n\n    combined_mouse_data = iso_concat([mouse_1, mouse_2], batch_type='numeric')\n\n\n    combined_mouse_data.obs_names_make_unique()\n    # Step 1: Remove any duplicate barcodes in the DataFrame\n    df_unique = df.drop_duplicates(subset='barcode')\n\n    # Step 2: Filter the DataFrame to include only the barcodes present in the AnnData object\n    df_filtered = df_unique[df_unique['barcode'].isin(combined_mouse_data.obs_names)]\n\n    # Step 3: Set the index of the filtered DataFrame to 'barcode' to make the merge easier\n    df_filtered.set_index('barcode', inplace=True)\n\n    # Step 4: Create a DataFrame from the obs DataFrame of the AnnData object to ensure the same index\n    obs_df = combined_mouse_data.obs.copy()\n\n    # Step 5: Initialize a new column 'cell_type' with NaN values in the obs DataFrame\n    obs_df['cell_type'] = pd.NA\n\n    # Step 6: Update the 'cell_type' column with values from the filtered DataFrame where indices match\n    obs_df.update(df_filtered['illumina.ident'].rename('cell_type'))\n\n    # Step 7: Ensure the index is unique and assign the updated DataFrame back to the obs attribute of the AnnData object\n    if obs_df.index.is_unique:\n        combined_mouse_data.obs = obs_df\n    else:\n        raise ValueError(\"The index of the obs DataFrame is not unique.\")\n\n    # Now, the 'cell_type' column should be added to the obs DataFrame of your AnnData object\n    combined_mouse_data = combined_mouse_data[~combined_mouse_data.obs['cell_type'].isna()]\n    combined_mouse_data.var\n    sc.pp.filter_genes(combined_mouse_data, min_cells=1)\n    sc.pp.filter_cells(combined_mouse_data, min_genes=1)\n    sc.pp.normalize_total(combined_mouse_data, target_sum=1e6)\n    sc.pp.log1p(combined_mouse_data)\n    sc.pp.neighbors(combined_mouse_data)\n    sc.tl.umap(combined_mouse_data)\n    sc.pl.umap(combined_mouse_data)\n    sc.pl.umap(combined_mouse_data,color = \"cell_type\")\n\n\n# run_tests()",
    "crumbs": [
      "003_readers_tests.html"
    ]
  },
  {
    "objectID": "005_switch_search.html",
    "href": "005_switch_search.html",
    "title": "allos",
    "section": "",
    "text": "source\n\nSwitchSearch\n\n SwitchSearch (anndata, cell_types=None)\n\nAn AnnData subclass with specialized Dirichlet-based and Wilcoxon-based isoform ‘switch’ detection methods, plus helper plots and caches.\n\nsource\n\n\nscattermap\n\n scattermap (color_data, marker_size=None, square=True, cmap='Reds',\n             cbar_kws=None, xticklabels=None, yticklabels=None, **kwargs)\n\nMinimal example of a “scattermap” function that draws circles whose color indicates one value and size indicates another. You likely have your own version. Adjust as needed, or remove if you define it elsewhere.\n\nsource\n\n\ncreate_iso_adata\n\n create_iso_adata (path:str)\n\n*Creates an AnnData object containing isoform counts from a Sicelore output file.\nParameters: - path (str): Path to the input file, which is expected to be tab-separated and contain: - transcriptId: Transcript identifiers. - geneId: Gene identifiers. - Transcript counts for individual barcodes (cells) as additional columns.\nReturns: - adata_iso (AnnData): An AnnData object with isoform counts.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npath\nstr\nPath to a tab-separated file, typically the Sicelore output with transcript counts.",
    "crumbs": [
      "005_switch_search.html"
    ]
  },
  {
    "objectID": "0100_test_.html",
    "href": "0100_test_.html",
    "title": "allos",
    "section": "",
    "text": "from allos.switch_search import SwitchSearch\nfrom allos.readers_tests import read_sicelore_isomatrix\n\nadata = read_sicelore_isomatrix(file_path = \"C:\\\\Users\\\\Anna\\\\Documents\\\\Promethion_run\\\\sicelore_out\\\\sicelore_isomatrix.txt\",\n    gene_id_label = \"geneId\",\n    transcript_id_label = \"transcriptId\",\n    remove_undef = True,\n    sparse = False)\n\n\n---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\nFile ~\\PycharmProjects\\allos\\.venv\\Lib\\site-packages\\pandas\\io\\parsers\\readers.py:626, in _read(filepath_or_buffer, kwds)\n    625 with parser:\n--&gt; 626     return parser.read(nrows)\n\nFile ~\\PycharmProjects\\allos\\.venv\\Lib\\site-packages\\pandas\\io\\parsers\\readers.py:1923, in TextFileReader.read(self, nrows)\n   1917 try:\n   1918     # error: \"ParserBase\" has no attribute \"read\"\n   1919     (\n   1920         index,\n   1921         columns,\n   1922         col_dict,\n-&gt; 1923     ) = self._engine.read(  # type: ignore[attr-defined]\n   1924         nrows\n   1925     )\n   1926 except Exception:\n\nFile ~\\PycharmProjects\\allos\\.venv\\Lib\\site-packages\\pandas\\io\\parsers\\c_parser_wrapper.py:234, in CParserWrapper.read(self, nrows)\n    233 if self.low_memory:\n--&gt; 234     chunks = self._reader.read_low_memory(nrows)\n    235     # destructive to chunks\n\nFile parsers.pyx:838, in pandas._libs.parsers.TextReader.read_low_memory()\n\nFile parsers.pyx:905, in pandas._libs.parsers.TextReader._read_rows()\n\nFile parsers.pyx:874, in pandas._libs.parsers.TextReader._tokenize_rows()\n\nFile parsers.pyx:891, in pandas._libs.parsers.TextReader._check_tokenize_status()\n\nFile parsers.pyx:2053, in pandas._libs.parsers.raise_parser_error()\n\nFile &lt;frozen codecs&gt;:331, in getstate(self)\n\nKeyboardInterrupt: \n\nDuring handling of the above exception, another exception occurred:\n\nKeyboardInterrupt                         Traceback (most recent call last)\nCell In[2], line 4\n      1 from allos.switch_search import SwitchSearch\n      2 from allos.readers_tests import read_sicelore_isomatrix\n----&gt; 4 adata = read_sicelore_isomatrix(file_path = \"C:\\\\Users\\\\Anna\\\\Documents\\\\Promethion_run\\\\sicelore_out\\\\sicelore_isomatrix.txt\",\n      5     gene_id_label = \"geneId\",\n      6     transcript_id_label = \"transcriptId\",\n      7     remove_undef = True,\n      8     sparse = False)\n\nFile ~\\PycharmProjects\\allos\\allos\\readers_tests.py:48, in read_sicelore_isomatrix(file_path, gene_id_label, transcript_id_label, remove_undef, sparse)\n     26 \"\"\"\n     27 Read a SiCeLoRe isomatrix file (tab-delimited) and convert it into a scanpy-compatible AnnData object.\n     28 \n   (...)\n     45     An AnnData object containing numeric data in `.X` and metadata in `.var`.\n     46 \"\"\"\n     47 # Read in the file, expecting rows to be features initially\n---&gt; 48 df = pd.read_csv(file_path, sep='\\t', index_col=0)\n     50 # Optionally remove rows marked as \"undef\" in the transcript column\n     51 if remove_undef and (transcript_id_label in df.columns):\n\nFile ~\\PycharmProjects\\allos\\.venv\\Lib\\site-packages\\pandas\\io\\parsers\\readers.py:1026, in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\n   1013 kwds_defaults = _refine_defaults_read(\n   1014     dialect,\n   1015     delimiter,\n   (...)\n   1022     dtype_backend=dtype_backend,\n   1023 )\n   1024 kwds.update(kwds_defaults)\n-&gt; 1026 return _read(filepath_or_buffer, kwds)\n\nFile ~\\PycharmProjects\\allos\\.venv\\Lib\\site-packages\\pandas\\io\\parsers\\readers.py:625, in _read(filepath_or_buffer, kwds)\n    622 if chunksize or iterator:\n    623     return parser\n--&gt; 625 with parser:\n    626     return parser.read(nrows)\n\nFile ~\\PycharmProjects\\allos\\.venv\\Lib\\site-packages\\pandas\\io\\parsers\\readers.py:1996, in TextFileReader.__exit__(self, exc_type, exc_value, traceback)\n   1990 def __exit__(\n   1991     self,\n   1992     exc_type: type[BaseException] | None,\n   1993     exc_value: BaseException | None,\n   1994     traceback: TracebackType | None,\n   1995 ) -&gt; None:\n-&gt; 1996     self.close()\n\nFile ~\\PycharmProjects\\allos\\.venv\\Lib\\site-packages\\pandas\\io\\parsers\\readers.py:1622, in TextFileReader.close(self)\n   1619     self.handles: IOHandles | None = None\n   1620     self._engine = self._make_engine(f, self.engine)\n-&gt; 1622 def close(self) -&gt; None:\n   1623     if self.handles is not None:\n   1624         self.handles.close()\n\nKeyboardInterrupt:"
  }
]