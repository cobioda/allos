[
  {
    "objectID": "metacells.html",
    "href": "metacells.html",
    "title": "Metacells",
    "section": "",
    "text": "import scanpy as sc\nfrom anndata import AnnData\nfrom typing import Optional, List\n\ndef create_pseudobulk_samples(adata: AnnData, \n                              donor_column: Optional[str] = None, \n                              cell_type_column: Optional[str] = None, \n                              metadata_columns: Optional[List[str]] = None,\n                              agg_func: str = \"sum\") -&gt; AnnData:\n    \"\"\"Create pseudobulk samples from single-cell data.\n\n    Parameters:\n    adata (AnnData): Annotated data matrix.\n    donor_column (str or None): Column name in `adata.obs` for donor information. If None, grouping will be done only using cell type.\n    cell_type_column (str or None): Column name in `adata.obs` for cell type information. If None, grouping will be done only using donor.\n    metadata_columns (list, optional): List of additional metadata columns to include.\n    agg_func (str): Aggregation function to use across cells. Options are 'sum' or 'mean'. Default is 'sum'.\n\n    Returns:\n    AnnData: Combined pseudobulk samples as an AnnData object.\n    \"\"\"\n    if metadata_columns is None:\n        metadata_columns = []\n\n    pseudobulk_list = []\n\n    # Determine which columns are provided for grouping.\n    grouping_keys = []\n    if donor_column is not None:\n        grouping_keys.append(donor_column)\n    if cell_type_column is not None:\n        grouping_keys.append(cell_type_column)\n\n    def aggregate_counts(subset):\n        if agg_func == \"sum\":\n            counts = subset.X.sum(axis=0)\n        elif agg_func == \"mean\":\n            counts = subset.X.mean(axis=0)\n        else:\n            raise ValueError(f\"Unsupported aggregation function: {agg_func}. Supported options are 'sum' and 'mean'.\")\n        if counts.ndim == 1:\n            counts = counts.reshape(1, -1)\n        return counts\n\n    if grouping_keys:\n        # Group by the available keys.\n        for group_key, group_df in adata.obs.groupby(grouping_keys):\n            # Ensure group_key is a tuple for consistent handling.\n            if not isinstance(group_key, tuple):\n                group_key = (group_key,)\n\n            # Subset the data using the indices from the grouping.\n            subset = adata[group_df.index, :]\n\n            # Compute aggregated pseudobulk counts.\n            pseudobulk_counts = aggregate_counts(subset)\n\n            # Create an AnnData object for the pseudobulk sample with counts in .X.\n            pseudobulk_adata = AnnData(X=pseudobulk_counts, var=subset.var[[]])\n\n            # Construct a sample name by joining the group values.\n            sample_name = \"_\".join([str(x) for x in group_key])\n            pseudobulk_adata.obs_names = [sample_name]\n\n            # Add the grouping metadata to the pseudobulk AnnData.\n            for col, val in zip(grouping_keys, group_key):\n                pseudobulk_adata.obs[col] = val\n\n            # Add additional metadata columns if provided (assuming consistency within groups).\n            for metadata in metadata_columns:\n                pseudobulk_adata.obs[metadata] = subset.obs[metadata].iloc[0]\n\n            pseudobulk_list.append(pseudobulk_adata)\n    else:\n        # If no grouping key is provided, aggregate all cells into one pseudobulk sample.\n        subset = adata\n        pseudobulk_counts = aggregate_counts(subset)\n        pseudobulk_adata = AnnData(X=pseudobulk_counts, var=subset.var[[]])\n        pseudobulk_adata.obs_names = [\"all\"]\n\n        # Add additional metadata columns if provided, taking the value from the first cell.\n        for metadata in metadata_columns:\n            pseudobulk_adata.obs[metadata] = subset.obs[metadata].iloc[0]\n\n        pseudobulk_list.append(pseudobulk_adata)\n\n    # Combine all pseudobulk samples into a single AnnData object.\n    pseudobulk_adata_combined = sc.concat(pseudobulk_list)\n    pseudobulk_adata_combined.var['geneId'] = adata.var['geneId']\n    pseudobulk_adata_combined.var_names = adata.var_names\n\n    return pseudobulk_adata_combined\n\n\nimport allos.preprocessing as pp\n\n\nmouse_data = pp.process_mouse_data()\n\n\n🔎 Looking for file at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File found at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt...\n✅ Decompression complete.\nTest data (mouse_1) downloaded successfully\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt...\n✅ Decompression complete.\nTest data (mouse_2) downloaded successfully\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/anndata/_core/anndata.py:1754: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n  utils.warn_names_duplicates(\"obs\")\n\n\n\nmouse_data\n\nView of AnnData object with n_obs × n_vars = 1109 × 31986\n    obs: 'batch', 'cell_type'\n    var: 'geneId'\n\n\n\nmouse_data = pp.filter_transcripts_by_abundance(mouse_data, threshold_pct = 2)\n\n\nmouse_data\n\nAnnData object with n_obs × n_vars = 1109 × 24917\n    obs: 'batch', 'cell_type'\n    var: 'geneId'\n\n\n\npsuedobulk = create_pseudobulk_samples(mouse_data, cell_type_column='cell_type', donor_column=None)\nsc.tl.pca(psuedobulk)\n# Ensure that the 'cell_type' metadata is treated as a categorical variable to avoid the unary '-' TypeError\npsuedobulk.obs['cell_type'] = psuedobulk.obs['cell_type'].astype('category')\nsc.pl.pca(psuedobulk, color='cell_type')\n\n\n\n\n\n\n\n\n\npsuedobulk = create_pseudobulk_samples(mouse_data, cell_type_column='cell_type', donor_column=None, agg_func = 'mean')\nsc.tl.pca(psuedobulk)\n# Ensure that the 'cell_type' metadata is treated as a categorical variable to avoid the unary '-' TypeError\npsuedobulk.obs['cell_type'] = psuedobulk.obs['cell_type'].astype('category')\nsc.pl.pca(psuedobulk, color='cell_type')\n\n\n\n\n\n\n\n\n\nimport scanpy as sc\nimport numpy as np\nimport pandas as pd\nfrom anndata import AnnData\nfrom sklearn.neighbors import NearestNeighbors\nfrom typing import Optional\n\ndef create_metacells(adata: AnnData,\n                     donor_column: Optional[str] = None,\n                     cell_type_column: Optional[str] = None,\n                     n_neighbors: int = 30,\n                     bagging_fraction: float = 0.8,\n                     n_pcs: int = 50,\n                     random_state: int = 0,\n                     agg_func: str = 'mean') -&gt; AnnData:\n    \"\"\"\n    Create metacells by KNN bagging while retaining cell type and donor labels.\n    \n    For each group (e.g. defined by donor and/or cell type), the function:\n      1. Computes PCA using a number of components that does not exceed the available data dimensions.\n         If the calculated number equals min(n_samples, n_features) and that value is &gt;1, it is reduced by one.\n      2. Uses NearestNeighbors to find each cell’s neighbors.\n      3. For each cell, a fraction of the candidate neighbors (including the cell itself)\n         is randomly sampled and aggregated (using either mean or sum) to create a metacell.\n      4. The group’s metadata (donor and cell type) is stored in the resulting metacell.\n    \n    Parameters:\n      adata: AnnData object with single-cell data.\n      donor_column: Column in adata.obs for donor info.\n      cell_type_column: Column in adata.obs for cell type info.\n      n_neighbors: Number of neighbors (excluding self) to consider.\n      bagging_fraction: Fraction of candidate neighbors (including self) to sample.\n      n_pcs: Desired number of principal components (will be reduced if group is small).\n      random_state: Seed for reproducibility.\n      agg_func: Aggregation function to combine counts, either 'mean' or 'sum'.\n    \n    Returns:\n      An AnnData object containing metacell profiles.\n    \"\"\"\n    np.random.seed(random_state)\n    metacell_list = []\n\n    # Build grouping keys.\n    grouping_keys = []\n    if donor_column is not None:\n        grouping_keys.append(donor_column)\n    if cell_type_column is not None:\n        grouping_keys.append(cell_type_column)\n\n    def process_subset(subset: AnnData, group_info: dict):\n        # If there is only one cell, bypass PCA.\n        if subset.shape[0] &lt; 2:\n            if hasattr(subset.X, \"toarray\"):\n                subset.obsm['X_pca'] = subset.X.toarray()\n            else:\n                subset.obsm['X_pca'] = subset.X\n        else:\n            # Calculate the minimum dimension.\n            min_dim = min(subset.shape[0], subset.shape[1])\n            n_components = min(n_pcs, min_dim)\n            # For svd_solver='arpack', n_components must be strictly less than min_dim.\n            if n_components == min_dim and min_dim &gt; 1:\n                n_components = min_dim - 1\n            sc.pp.pca(subset, n_comps=n_components, random_state=random_state)\n        \n        # Adjust neighbor search so we don't request more neighbors than cells.\n        effective_neighbors = min(n_neighbors + 1, subset.shape[0])\n        nbrs = NearestNeighbors(n_neighbors=effective_neighbors, metric='euclidean')\\\n                .fit(subset.obsm['X_pca'])\n        knn_indices = nbrs.kneighbors(subset.obsm['X_pca'], return_distance=False)\n        \n        # For each cell, form a metacell by sampling a fraction of its neighbors.\n        for i, cell in enumerate(subset.obs_names):\n            candidate_indices = knn_indices[i]\n            bag_size = max(1, int(np.ceil(bagging_fraction * len(candidate_indices))))\n            sampled = np.random.choice(candidate_indices, size=bag_size, replace=False)\n            expr_subset = subset.X[sampled]\n            if hasattr(expr_subset, \"toarray\"):\n                expr_subset = expr_subset.toarray()\n            if agg_func == 'mean':\n                metacell_expr = expr_subset.mean(axis=0)\n            elif agg_func == 'sum':\n                metacell_expr = expr_subset.sum(axis=0)\n            else:\n                raise ValueError(\"Invalid agg_func. Choose either 'mean' or 'sum'.\")\n            metacell = AnnData(X=metacell_expr.reshape(1, -1), var=subset.var.copy())\n            meta = group_info.copy()\n            meta['seed_cell'] = cell\n            metacell.obs = pd.DataFrame(meta, index=[f\"{cell}_metacell\"])\n            metacell_list.append(metacell)\n\n    if grouping_keys:\n        # Process each group so that metacells never mix donors or cell types.\n        grouped = adata.obs.groupby(grouping_keys)\n        for group_key, group_df in grouped:\n            if not isinstance(group_key, tuple):\n                group_key = (group_key,)\n            group_info = {key: val for key, val in zip(grouping_keys, group_key)}\n            subset = adata[group_df.index].copy()\n            process_subset(subset, group_info)\n    else:\n        process_subset(adata.copy(), {})\n\n    metacells_combined = sc.concat(metacell_list)\n    metacells_combined.var_names = adata.var_names\n    metacells_combined.var['geneId'] = adata.var['geneId']\n    return metacells_combined\n\n\nmetacells = create_metacells(mouse_data, cell_type_column='cell_type')\nsc.pp.neighbors(metacells)\n# Ensure that the 'cell_type' metadata is treated as a categorical variable to avoid the unary '-' TypeError\nmetacells.obs['cell_type'] = metacells.obs['cell_type'].astype('category')\nsc.tl.umap(metacells)\nsc.pl.umap(metacells, color='cell_type')\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/scanpy/tools/_utils.py:41: UserWarning: You’re trying to run this on 24917 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n  warnings.warn(\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n\n\n\n\n\n\n\n\n\n\nmetacells = create_metacells(mouse_data, cell_type_column='cell_type', agg_func='sum')\nsc.pp.neighbors(metacells)\n# Ensure that the 'cell_type' metadata is treated as a categorical variable to avoid the unary '-' TypeError\nmetacells.obs['cell_type'] = metacells.obs['cell_type'].astype('category')\nsc.tl.umap(metacells)\nsc.pl.umap(metacells, color='cell_type')\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/scanpy/tools/_utils.py:41: UserWarning: You’re trying to run this on 24917 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n  warnings.warn(\n\n\n\n\n\n\n\n\n\n\nfrom allos.switch_search import SwitchSearch\n\n\nss = SwitchSearch(metacells)\n\n\nmetacells.var\n\n\n\n\n\n\n\n\ngeneId\n\n\ntranscriptId\n\n\n\n\n\nENSMUST00000156717.1\nKlc2\n\n\nENSMUST00000212520.1\nCapn15\n\n\nENSMUST00000025798.12\nKlc2\n\n\nENSMUST00000231280.1\nEva1c\n\n\nENSMUST00000039286.4\nAtg5\n\n\n...\n...\n\n\nENSMUST00000213971.1\nZfp445\n\n\nENSMUST00000047275.7\nBace2\n\n\nENSMUST00000019994.13\nPopdc3\n\n\nENSMUST00000127375.1\nSnx11\n\n\nENSMUST00000044234.13\nTgfbr1\n\n\n\n\n24917 rows × 1 columns\n\n\n\n\nswitches = ss.find_switching_isoforms_wilcoxon(n_jobs=10, cell_group_column='cell_type')\n\n\nswitches.sort_values(by='pvals_adj', ascending= False)\n\n\n\n\n\n\n\n\ntranscript_id\nscores\nlog_fold_change\npvals\npvals_adj\ngroup_1\ngroup_2\ncontrast\ngene_id\nn_cells_group_1\nn_cells_group_2\ntotal_cells\np_value\ndirection\npercent_expressed_group_1\npercent_expressed_group_2\n\n\n\n\n32987\nENSMUST00000164893.7\n5.225940\n33.510654\n1.732727e-07\n1.214469e-06\nmature GABAergic\nCajal-Retzius\nCajal-Retzius__mature GABAergic\nNol4\n172\n16\n188\n1.214528e-06\n-33.510654\n79.069767\n0.000000\n\n\n54957\nENSMUST00000024056.9\n5.259562\n0.983016\n1.443985e-07\n1.031530e-06\nmature GABAergic\nCajal-Retzius\nCajal-Retzius__mature GABAergic\nUbe2j2\n172\n16\n188\n1.031979e-06\n-0.983016\n100.000000\n100.000000\n\n\n43037\nENSMUST00000106599.7\n5.317202\n1.225731\n1.053753e-07\n7.742956e-07\nmature GABAergic\nCajal-Retzius\nCajal-Retzius__mature GABAergic\nRpl38\n172\n16\n188\n7.751318e-07\n-1.225731\n98.255814\n100.000000\n\n\n57332\nENSMUST00000115258.8\n5.338022\n33.390598\n9.396606e-08\n7.056517e-07\nimature GABAergic\nCajal-Retzius\nCajal-Retzius__imature GABAergic\nZcchc12\n141\n16\n157\n7.064480e-07\n-33.390598\n81.560284\n0.000000\n\n\n16140\nENSMUST00000035934.6\n5.346021\n0.738823\n8.990872e-08\n6.697326e-07\nmature GABAergic\nCajal-Retzius\nCajal-Retzius__mature GABAergic\nExoc3\n172\n16\n188\n6.707262e-07\n-0.738823\n100.000000\n100.000000\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n8068\nENSMUST00000114934.10\n17.758089\n3.007974\n1.492280e-70\n5.468108e-68\nmature GABAergic\nmature Glutamatergic\nmature GABAergic__mature Glutamatergic\nCelf2\n172\n275\n447\n1.759541e-65\n3.007974\n100.000000\n92.727273\n\n\n14082\nENSMUST00000115559.9\n17.797220\n36.442566\n7.426388e-71\n3.672421e-68\nmature Glutamatergic\nmature GABAergic\nmature GABAergic__mature Glutamatergic\nDync1i1\n275\n172\n447\n1.246295e-65\n-36.442566\n100.000000\n0.000000\n\n\n31168\nENSMUST00000164181.1\n17.854618\n0.583592\n2.660910e-71\n5.765383e-69\nmature Glutamatergic\nimature Glutamatergic\nimature Glutamatergic__mature Glutamatergic\nMyl6\n275\n234\n509\n3.113507e-66\n-0.583592\n100.000000\n100.000000\n\n\n28909\nENSMUST00000110907.7\n18.555452\n2.953794\n7.368487e-77\n2.585924e-74\nimature Glutamatergic\nmature Glutamatergic\nimature Glutamatergic__mature Glutamatergic\nMeis2\n234\n275\n509\n2.261919e-71\n2.953794\n100.000000\n80.363636\n\n\n28908\nENSMUST00000110908.8\n18.559080\n3.829144\n6.887374e-77\n2.451610e-74\nimature Glutamatergic\nmature Glutamatergic\nimature Glutamatergic__mature Glutamatergic\nMeis2\n234\n275\n509\n2.175068e-71\n3.829144\n99.145299\n67.636364\n\n\n\n\n2009 rows × 16 columns\n\n\n\n\nimport allos.visuals as vs\n\n\nvs.plot_transcript_exspression_dotplot(metacells, gene_id='Nol4')\n\n\n\n\n\n\n\n\n\nvs.plot_transcript_exspression_dotplot(mouse_data, gene_id='Nol4')",
    "crumbs": [
      "Metacells"
    ]
  },
  {
    "objectID": "visuals.html",
    "href": "visuals.html",
    "title": "Visualizations",
    "section": "",
    "text": "from allos.readers_tests import *\nfrom allos.preprocessing import subset_common_cells, transfer_obs\n\n\ncombined_mouse_data = process_mouse_data()\n\n\n🔎 Looking for file at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File found at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt...\n✅ Decompression complete.\nTest data (mouse_1) downloaded successfully\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt...\n✅ Decompression complete.\nTest data (mouse_2) downloaded successfully\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/anndata/_core/anndata.py:1754: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n  utils.warn_names_duplicates(\"obs\")\n\n\n\nimport scanpy as sc\nfrom allos.preprocessing import get_sot_gene_matrix\n\n\nmouse_data_gene = get_sot_gene_matrix(combined_mouse_data)\nsc.pp.normalize_total(mouse_data_gene,target_sum = 1e6)\nsc.pp.log1p(mouse_data_gene)\nsc.pp.neighbors(mouse_data_gene)\nsc.tl.umap(mouse_data_gene)\nsc.pl.umap(mouse_data_gene, color = 'cell_type')\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/scanpy/tools/_utils.py:41: UserWarning: You’re trying to run this on 12561 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n  warnings.warn(\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n\n\n\n\n\n\n\n\n\n\nsc.pl.umap(mouse_data_gene, color = 'Clta')\n\n\n\n\n\n\n\n\n\nsc.pp.normalize_total(combined_mouse_data,target_sum = 1e6)\nsc.pp.log1p(combined_mouse_data)\nsc.pp.neighbors(combined_mouse_data)\nsc.tl.umap(combined_mouse_data)\nsc.pl.umap(combined_mouse_data, color = 'cell_type')\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/scanpy/preprocessing/_normalization.py:207: UserWarning: Received a view of an AnnData. Making a copy.\n  view_to_actual(adata)\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/scanpy/tools/_utils.py:41: UserWarning: You’re trying to run this on 31986 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n  warnings.warn(\n\n\n\n\n\n\n\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Parameters:\n  else: warn(msg)\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Returns:\n  else: warn(msg)\n\nsource\n\nplot_transcripts\n\n plot_transcripts (adata, gene_id=None, transcripts=None)\n\nPlot the UMAP with the specified transcripts or transcripts associated with the given gene ID.\n\nplot_transcripts(combined_mouse_data, gene_id='Clta')\n\n\n\n\n\n\n\n\n\nplot_transcripts(combined_mouse_data, transcripts=['ENSMUST00000170241.7','ENSMUST00000107849.9'])\n\n\n\n\n\n\n\n\n\nsource\n\n\nplot_density\n\n plot_density (adata, feature, basis='umap', adjust=1.0, cmap='viridis')\n\nSimple scatterplot colored by the weighted density of feature.\n\nsource\n\n\ncalculate_density\n\n calculate_density (adata, feature, basis='umap', adjust=1.0,\n                    map_to_cells=True)\n\n1) Extract coordinates from adata.obsm[f”X_{basis}”]. 2) Extract expression vector for feature. 3) Run the weighted KDE. 4) If map_to_cells=True, return per-cell densities; else return the full grid.\n\nsource\n\n\nget_dens\n\n get_dens (points, dens)\n\nMap each 2D point to the approximate density in dens[\"z\"]. This mimics the R code that uses findInterval. points: shape (n_cells, 2) dens : dict with ‘x’, ‘y’, ‘z’, from wkde2d Returns a 1D np.array of densities (one per row in points).\n\nsource\n\n\nwkde2d\n\n wkde2d (x, y, w=None, h=None, adjust=1.0, n=100, lims=None)\n\nPython equivalent of your R ‘wkde2d’ function: x, y: coordinates (1D arrays) for each observation. w : weight vector (same length as x, y). h : tuple or scalar for bandwidth in the x/y directions (if None, use approximate). adjust: bandwidth adjustment scalar. n : number of grid points in each direction. lims: [x_min, x_max, y_min, y_max] to define the grid. Returns a dict with {‘x’: gx, ‘y’: gy, ‘z’: Z}, analogous to R’s list(x=…, y=…, z=…).\n\nsource\n\n\nnormal_reference_bandwidth\n\n normal_reference_bandwidth (x)\n\nApproximate the normal-reference (Silverman’s) bandwidth for 1D data. R’s ks::hpi uses a more sophisticated pilot estimation, but this is often ‘close enough’ for large data.\n\nplot_density(combined_mouse_data, 'ENSMUST00000170241.7', basis= 'umap')\n\n\n\n\n\n\n\n\n\nsource\n\n\nplot_density_multi\n\n plot_density_multi (adata, features, basis='umap', adjust=1.0,\n                     cmap='viridis')\n\nPlot one or multiple features’ density on the specified 2D embedding. - If ‘features’ is a single string, makes one subplot. - If ‘features’ is a list of strings, makes multiple side-by-side subplots.\n\nplot_density_multi(\n    adata=combined_mouse_data,\n    features=['ENSMUST00000170241.7', 'ENSMUST00000107849.9'],\n    basis='umap'\n)\n\n\n\n\n\n\n\n\n\nsource\n\n\nplot_transcript_exspression_dotplot\n\n plot_transcript_exspression_dotplot (adata, gene_id,\n                                      cell_labels_column='cell_type',\n                                      top_n=5)\n\n*Plot isoform expression for a selected gene across cell types, with dot color = average expression, and dot size = percent of cells expressing. Two legends: a colorbar for average expression, and a bubble-size legend for pct_expressing.\nDIFFERENT LAYOUT APPROACH: - We use a single figure+axes with plt.tight_layout(rect=[…]) to reserve space on the right. - We place the bubble-size legend as an “in-figure” legend using bbox_to_anchor, so it won’t be cut off.*\n\nplot_transcript_exspression_dotplot(combined_mouse_data, gene_id='Clta', top_n=5)\n\n\n\n\n\n\n\n\n\nsource\n\n\nplot_transcript_expression_violin\n\n plot_transcript_expression_violin (adata, gene_id,\n                                    cell_labels_column='cell_type',\n                                    top_n=5, figsize_per_isoform=(4, 4))\n\nPlot isoform expression for a selected gene across cell types, using violin plots (with each cell’s expression as a point).\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nadata\nAnnData\n\nSingle-cell AnnData object with .obs (cells) and .var (features).\n\n\ngene_id\nstr\n\nThe gene ID to filter isoforms by (adata.var[‘geneId’]).\n\n\ncell_labels_column\nstr\ncell_type\nColumn name in adata.obs specifying the cell type or cluster label.\n\n\ntop_n\nint\n5\nIf not None, keeps only the top-n isoforms by overall mean expression.\n\n\nfigsize_per_isoform\ntuple\n(4, 4)\nWidth and height (in inches) for each isoform subplot.\n\n\n\n\nplot_transcript_expression_violin(combined_mouse_data,  gene_id='Clta', top_n=5)\n\n\n\n\n\n\n\n\n\nimport nbdev; nbdev.nbdev_export()",
    "crumbs": [
      "Visualizations"
    ]
  },
  {
    "objectID": "anndata_iso.html",
    "href": "anndata_iso.html",
    "title": "IsoAdata",
    "section": "",
    "text": "from allos.readers_tests import *\nfrom allos.preprocessing import subset_common_cells, transfer_obs\n\n\ncombined_mouse_data = process_mouse_data()\n\nStarting download of test data from https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM3748nnn/GSM3748087/suppl/GSM3748087%5F190c.isoforms.matrix.txt.gz\nFile downloaded successfully\nFile extracted successfully\nTest data downloaded successfully\nStarting download of test data from https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM3748nnn/GSM3748089/suppl/GSM3748089%5F951c.isoforms.matrix.txt.gz\nFile downloaded successfully\nFile extracted successfully\nTest data downloaded successfully\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/anndata/_core/anndata.py:1754: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n  utils.warn_names_duplicates(\"obs\")\n\n\n\ncombined_mouse_data.obs.index\n\nIndex(['CCACCTACAAAGTCAA', 'AACCATGAGACCACGA', 'GATGAGGTCGACCAGC',\n       'GCACTCTTCTATCGCC', 'TGCCCTAAGGCCCGTT', 'TTCGGTCAGCTGGAAC',\n       'GGATTACAGACGCAAC', 'GTCTCGTTCCTCTAGC', 'CCATGTCAGTAGATGT',\n       'GATCGATGTCAAACTC',\n       ...\n       'GCTCCTACATCGACGC', 'AGCGTCGCATTATCTC', 'ATCCACCTCCCACTTG',\n       'GTGCTTCCAAGGCTCC', 'GACTACATCATTGCGA', 'TACTCATTCGCCATAA',\n       'CGTGAGCTCTCTAAGG', 'TTATGCTAGTAAGTAC', 'CGGACACTCTTGTCAT',\n       'GGCTCGAGTACCGAGA'],\n      dtype='object', length=1109)\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section See Also\n  else: warn(msg)\n\nsource\n\nAnnDataIso\n\n AnnDataIso (anndata:anndata._core.anndata.AnnData, palette='ghibli')\n\n*An annotated data matrix.\n.. figure:: ../_static/img/anndata_schema.svg :width: 260px :align: right :class: dark-light\n:class:~anndata.AnnData stores a data matrix :attr:X together with annotations of observations :attr:obs (:attr:obsm, :attr:obsp), variables :attr:var (:attr:varm, :attr:varp), and unstructured annotations :attr:uns.\nAn :class:~anndata.AnnData object adata can be sliced like a :class:~pandas.DataFrame, for instance adata_subset = adata[:, list_of_variable_names]. :class:~anndata.AnnData’s basic structure is similar to R’s ExpressionSet [Huber15]_. If setting an .h5ad-formatted HDF5 backing file .filename, data remains on the disk but is automatically loaded into memory if needed.*",
    "crumbs": [
      "IsoAdata"
    ]
  },
  {
    "objectID": "palettes.html",
    "href": "palettes.html",
    "title": "Palettes",
    "section": "",
    "text": "import seaborn as sns\nimport matplotlib.pyplot as plt\n# Display the color palette\nsns.palplot(synthwave)\nplt.show()\n\n\n\n\n\n\n\n\n\nsns.palplot(ghibli)\nplt.show()",
    "crumbs": [
      "Palettes"
    ]
  },
  {
    "objectID": "transcript_plots.html",
    "href": "transcript_plots.html",
    "title": "Transcript plots",
    "section": "",
    "text": "from allos.transcript_data import TranscriptData\n\n\nimport os\nimport urllib.request\nfrom pathlib import Path\n\n\nfrom allos.transcript_data import TranscriptData\n\n\nsource\n\nTranscriptPlots\n\n TranscriptPlots (gtf_file=None, reference_fasta=None, intron_scale=0.1)\n\nintron_scale: factor (between 0 and 1) by which intronic regions are compressed.\n\nsource\n\n\nmerge_intervals\n\n merge_intervals (intervals)\n\nMerge a list of [start, end] intervals.\n\nsource\n\n\nTranscriptPlots\n\n TranscriptPlots (gtf_file=None, reference_fasta=None, intron_scale=0.1)\n\nintron_scale: factor (between 0 and 1) by which intronic regions are compressed.\n\nsource\n\n\nmerge_intervals\n\n merge_intervals (intervals)\n\nMerge a list of [start, end] intervals.\n\nimport os\nimport urllib.request\nfrom pathlib import Path\n\n# Example Ensembl URLs for mouse GRCm39 (release 109)\ngtf_url = \"ftp://ftp.ensembl.org/pub/release-109/gtf/mus_musculus/Mus_musculus.GRCm39.109.gtf.gz\"\nfasta_url = \"ftp://ftp.ensembl.org/pub/release-109/fasta/mus_musculus/dna/Mus_musculus.GRCm39.dna.primary_assembly.fa.gz\"\n\n# Store data one directory back\ndata_dir = Path(\"..\") / \"data\"\ndata_dir.mkdir(parents=True, exist_ok=True)\n\ngtf_file_local = data_dir / \"Mus_musculus.GRCm39.109.gtf.gz\"\nfasta_file_local = data_dir / \"Mus_musculus.GRCm39.dna.primary_assembly.fa.gz\"\n\n# Download if not already present\nif not gtf_file_local.is_file():\n    print(f\"Downloading {gtf_url}...\")\n    urllib.request.urlretrieve(gtf_url, gtf_file_local)\n\nif not fasta_file_local.is_file():\n    print(f\"Downloading {fasta_url}...\")\n    urllib.request.urlretrieve(fasta_url, fasta_file_local)\n\nTo initialise class:\n\ntp = TranscriptPlots(gtf_file=gtf_file_local)\n\n\nimport allos.preprocessing as pp\n\nmouse_data = pp.process_mouse_data()\n\n\n🔎 Looking for file at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File found at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt...\n✅ Decompression complete.\nTest data (mouse_1) downloaded successfully\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt...\n✅ Decompression complete.\nTest data (mouse_2) downloaded successfully\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/anndata/_core/anndata.py:1754: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n  utils.warn_names_duplicates(\"obs\")\n\n\n\nmouse_data.obs\n\n\n\n\n\n\n\n\nbatch\ncell_type\n\n\n\n\nCCACCTACAAAGTCAA\n0\nmature Glutamatergic\n\n\nAACCATGAGACCACGA\n0\nCajal-Retzius\n\n\nGATGAGGTCGACCAGC\n0\nimature Glutamatergic\n\n\nGCACTCTTCTATCGCC\n0\nimature Glutamatergic\n\n\nTGCCCTAAGGCCCGTT\n0\nintermediate progenitor\n\n\n...\n...\n...\n\n\nTACTCATTCGCCATAA\n1\nmature GABAergic\n\n\nCGTGAGCTCTCTAAGG\n1\nimature Glutamatergic\n\n\nTTATGCTAGTAAGTAC\n1\nmature GABAergic\n\n\nCGGACACTCTTGTCAT\n1\nradial glia\n\n\nGGCTCGAGTACCGAGA\n1\nmature GABAergic\n\n\n\n\n1109 rows × 2 columns\n\n\n\n\ntp.compare_two_celltypes_psi(adata=mouse_data, gene_name='Clta', label_column='cell_type', group1='imature Glutamatergic', group2= 'radial glia', celltype1_label='imature Glutamatergic', celltype2_label='Radial Glia')\n\n\n\n\n\n\n\n\n\ntp.get_transcript_info('ENSMUST00000044492')\n\n{'transcript_id': 'ENSMUST00000044492',\n 'transcript_name': 'Akap9-201',\n 'transcript_type': 'unknown',\n 'cds_start': 3978442,\n 'cds_end': 4129693,\n 'chromosome': '5',\n 'strand': '+'}\n\n\nTo plot a panel for one or several transcripts:\n\ntp.draw_transcripts_list(['ENSMUST00000044492', 'ENSMUST00000143365'], colors=ghibli, draw_cds=True)\n\n\n---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\nCell In[15], line 1\n----&gt; 1 tp.draw_transcripts_list(['ENSMUST00000044492', 'ENSMUST00000143365'], colors=ghibli, draw_cds=True)\n\nCell In[7], line 881, in TranscriptPlots.draw_transcripts_list(self, transcripts_ids, colors, draw_cds)\n    879 if draw_cds and self.transcript_data is None:\n    880     raise Exception('A GTF file is necessary in order to display the CDS region')\n--&gt; 881 self._draw_transcripts_list(transcripts_ids, None, colors, draw_cds=draw_cds)\n\nCell In[7], line 867, in TranscriptPlots._draw_transcripts_list(self, transcripts_ids, _ax, colors, draw_cds)\n    865 for i, (ex, di, co, tid) in enumerate(zip(exons_list, directions, colors, transcripts_ids)):\n    866     offset = -0.5 * i\n--&gt; 867     self._draw_transcript(ex, di, co, tid, mapping_fn,\n    868                           offset=offset, with_cds=draw_cds)\n    869 if _ax is None:\n    870     plt.show()\n\nCell In[7], line 716, in TranscriptPlots._draw_transcript(self, exons, direction, color, transcript_name, mapping_fn, offset, with_cds)\n    713 j, k = (0, 1) if direction == 1 else (1, 0)\n    715 if with_cds:\n--&gt; 716     t_info = self.get_transcript_info(transcript_name)\n    717     cds_start, cds_end = t_info['cds_start'], t_info['cds_end']\n    718 else:\n\nCell In[7], line 633, in TranscriptPlots.get_transcript_info(self, transcript_id)\n    631     raise NotImplementedError(\"Transcript info not available; please supply a GTF file.\")\n    632 else:\n--&gt; 633     return self.transcript_data.get_transcript_info(transcript_id)\n\nFile /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/transcript_data.py:614, in TranscriptData.get_transcript_info(self, transcript_id)\n    604 def get_transcript_info(self, transcript_id: str) -&gt; Dict[str, Any]:\n    605     \"\"\"\n    606     Return a dictionary with basic info about the given transcript, including:\n    607     - transcript_id\n   (...)\n    612     - strand (either '+' or '-')\n    613     \"\"\"\n--&gt; 614     df = self.gr.df\n    615     sub = df[df.transcript_id == transcript_id]\n    617     # If we didn't find this transcript at all, return an empty dict or raise an error.\n\nFile /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/pyranges/pyranges_main.py:1511, in PyRanges.df(self)\n   1502 @property\n   1503 def df(self):\n   1504     \"\"\"Return PyRanges as DataFrame.\n   1505 \n   1506     See also\n   1507     --------\n   1508 \n   1509     PyRanges.as_df : return PyRanges as DataFrame.\"\"\"\n-&gt; 1511     return self.as_df()\n\nFile /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/pyranges/pyranges_main.py:800, in PyRanges.as_df(self)\n    798     return self.values()[0]\n    799 else:\n--&gt; 800     return pd.concat(self.values()).reset_index(drop=True)\n\nFile /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/pandas/core/frame.py:6417, in DataFrame.reset_index(self, level, drop, inplace, col_level, col_fill, allow_duplicates, names)\n   6415     new_obj = self\n   6416 else:\n-&gt; 6417     new_obj = self.copy(deep=None)\n   6418 if allow_duplicates is not lib.no_default:\n   6419     allow_duplicates = validate_bool_kwarg(allow_duplicates, \"allow_duplicates\")\n\nFile /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/pandas/core/generic.py:6811, in NDFrame.copy(self, deep)\n   6662 @final\n   6663 def copy(self, deep: bool_t | None = True) -&gt; Self:\n   6664     \"\"\"\n   6665     Make a copy of this object's indices and data.\n   6666 \n   (...)\n   6809     dtype: int64\n   6810     \"\"\"\n-&gt; 6811     data = self._mgr.copy(deep=deep)\n   6812     self._clear_item_cache()\n   6813     return self._constructor_from_mgr(data, axes=data.axes).__finalize__(\n   6814         self, method=\"copy\"\n   6815     )\n\nFile /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/pandas/core/internals/managers.py:593, in BaseBlockManager.copy(self, deep)\n    590     else:\n    591         new_axes = list(self.axes)\n--&gt; 593 res = self.apply(\"copy\", deep=deep)\n    594 res.axes = new_axes\n    596 if self.ndim &gt; 1:\n    597     # Avoid needing to re-compute these\n\nFile /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/pandas/core/internals/managers.py:363, in BaseBlockManager.apply(self, f, align_keys, **kwargs)\n    361         applied = b.apply(f, **kwargs)\n    362     else:\n--&gt; 363         applied = getattr(b, f)(**kwargs)\n    364     result_blocks = extend_blocks(applied, result_blocks)\n    366 out = type(self).from_blocks(result_blocks, self.axes)\n\nFile /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/pandas/core/internals/blocks.py:796, in Block.copy(self, deep)\n    794 refs: BlockValuesRefs | None\n    795 if deep:\n--&gt; 796     values = values.copy()\n    797     refs = None\n    798 else:\n\nKeyboardInterrupt: \n\n\n\n\n\n\n\n\n\n\n\n#\n\nget_transcript_info helps to retrieve information about the transcripts of interest:\n\n# import pandas as pd  \n\n# transcripts = [\"ENSMUST00000107851\", \"ENSMUST00000107846\", \"ENSMUST00000107847\"]\n# transcripts_info = []\n\n# for i in transcripts:\n#     transcripts_info.append(tp.get_transcript_info(i))  # Append transcript info to list\n\n# df = pd.DataFrame(transcripts_info)  # Convert list of dictionaries to DataFrame\n# print(df)  # Display the DataFrame\n\n        transcript_id transcript_name transcript_type  cds_start   cds_end  \\\n0  ENSMUST00000107851        Clta-205         unknown   44012791  44032569   \n1  ENSMUST00000107846        Clta-202         unknown   44012791  44032569   \n2  ENSMUST00000107847        Clta-203         unknown   44012791  44032569   \n\n  chromosome strand  \n0          4      +  \n1          4      +  \n2          4      +  \n\n\n“draw_transcript_list_unscaled” keeps the structure of transcripts but shortens the introns. It is useful to compare the structure of transcipts with extremely long introns:\n\n# tp.draw_transcripts_list_unscaled([\"ENSMUST00000107851\", \"ENSMUST00000107846\", \"ENSMUST00000107847\"], colors=ghibli)\n\n\n\n\n\n\n\n\nIf neither gtf nor fasta is provided, the transcripts can be provided as ensembl id and the coordinates will be fetched from ensembl api.\n\n# #cage_peaks = \"https://fantom.gsc.riken.jp/5/datafiles/reprocessed/mm10_latest/extra/CAGE_peaks/mm10_fair+new_CAGE_peaks_phase1and2.bed.gz\"\n# cage_peaks = \"https://reftss.riken.jp/datafiles/current/mouse/refTSS_v4.1_mouse_coordinate.mm39.bed.gz\"\n\n\n# def download_and_extract_bed(url, local_folder):\n#     \"\"\"\n#     Downloads and extracts a BED file from a given URL if it doesn't already exist.\n    \n#     Parameters:\n#     - url (str): The URL of the `.bed.gz` file to download.\n#     - local_folder (str): The folder where the file should be saved.\n    \n#     Returns:\n#     - str: Path to the extracted BED file.\n#     \"\"\"\n#     # Ensure local folder exists\n#     os.makedirs(local_folder, exist_ok=True)\n\n#     # Extract filename from URL\n#     filename = os.path.basename(url)\n#     compressed_file = os.path.join(local_folder, filename)\n#     extracted_file = compressed_file.replace(\".gz\", \"\")\n\n#     # Check if extracted file already exists\n#     if os.path.exists(extracted_file):\n#         print(f\"Extracted BED file already exists: {extracted_file}\")\n#         return extracted_file\n\n#     # Download if necessary\n#     if not os.path.exists(compressed_file):\n#         print(f\"Downloading {compressed_file}...\")\n#         response = requests.get(url, stream=True)\n#         with open(compressed_file, \"wb\") as f:\n#             shutil.copyfileobj(response.raw, f)\n#         print(\"Download complete.\")\n\n#     # Extract the file\n#     print(f\"Extracting {compressed_file}...\")\n#     with gzip.open(compressed_file, \"rb\") as f_in, open(extracted_file, \"wb\") as f_out:\n#         shutil.copyfileobj(f_in, f_out)\n#     print(f\"Extraction complete: {extracted_file}\")\n\n#     return extracted_file\n\n\n# cage_peaks = download_and_extract_bed(cage_peaks, \"../data/\")\n\nExtracted BED file already exists: ../data/refTSS_v4.1_mouse_coordinate.mm39.bed\n\n\n\n# import pandas as pd\n# #col_names = [\"chrom\", \"start\", \"end\", \"name\", \"score\", \"strand\"]\n# cage_df = pd.read_csv(cage_peaks, sep=\"\\t\", comment='#')\n\n\n# cage_df\n\n\n\n\n\n\n\n\nchromosome\nstart\nend\nrefTSS_ID\nscore\nstrand\n\n\n\n\n0\nchr1\n3221101\n3221109\nrfmm_1.1\n1\n+\n\n\n1\nchr1\n3226272\n3226277\nrfmm_2.1\n1\n+\n\n\n2\nchr1\n3389727\n3389730\nrfmm_3.1\n1\n-\n\n\n3\nchr1\n3448009\n3448012\nrfmm_4.1\n1\n-\n\n\n4\nchr1\n3559372\n3559376\nrfmm_5.1\n1\n-\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n172319\nchrY\n90831164\n90831167\nrfmm_172320.1\n1\n+\n\n\n172320\nchrY\n90831173\n90831188\nrfmm_172321.1\n1\n+\n\n\n172321\nchrY\n90831968\n90831970\nrfmm_172322.1\n1\n+\n\n\n172322\nchrY\n90836575\n90836577\nrfmm_172323.1\n1\n-\n\n\n172323\nchrY\n90839978\n90840019\nrfmm_172324.1\n1\n-\n\n\n\n\n172324 rows × 6 columns\n\n\n\n\n# find the tss that overlap with the gene coordinates:\n# get the coordinates of plot transcript panel, find the tss coordinates \n# that are inside these limits (pos_end, pos_start in _draw_transcript):\n\n\n# def extract_genes_from_gtf(gtf_gz_path, output_gtf, gene_ids):\n#     \"\"\"\n#     Extracts specified genes from a GTF file inside a .gz archive and writes a new GTF file.\n\n#     Parameters:\n#     - gtf_gz_path (str): Path to the original GTF .gz file.\n#     - output_gtf (str): Path for the new GTF file.\n#     - gene_ids (list): List of gene IDs to extract (e.g., [\"ENSMUSG00000025902\", \"ENSMUSG00000025903\"]).\n#     \"\"\"\n#     extracted_gtf_path = gtf_gz_path.rstrip(\".gz\")  # Remove .gz extension for the extracted file\n\n#     # Check if extracted file already exists\n#     from pathlib import Path\n#     if not Path(extracted_gtf_path).exists():\n#         print(f\"🔄 Extracting {gtf_gz_path}...\")\n#         with gzip.open(gtf_gz_path, \"rt\") as gz_file, open(extracted_gtf_path, \"w\") as out_file:\n#             shutil.copyfileobj(gz_file, out_file)\n#         print(f\"✅ Extracted: {extracted_gtf_path}\")\n#     else:\n#         print(f\"📂 Using existing extracted file: {extracted_gtf_path}\")\n\n#     # Read the extracted GTF file, skipping comment lines\n#     gtf = pd.read_csv(extracted_gtf_path, sep=\"\\t\", comment='#', header=None, dtype=str)\n\n#     # GTF column names based on Ensembl/Gencode format\n#     gtf.columns = [\n#         \"seqname\", \"source\", \"feature\", \"start\", \"end\", \"score\",\n#         \"strand\", \"frame\", \"attribute\"\n#     ]\n\n#     # Extract gene IDs from the 'attribute' column\n#     def get_gene_id(attribute):\n#         for entry in attribute.split(\";\"):\n#             entry = entry.strip()\n#             if entry.startswith(\"gene_id\"):\n#                 return entry.split(\" \")[1].strip('\"')\n#         return None\n\n#     # Filter GTF for the selected genes\n#     gtf[\"gene_id\"] = gtf[\"attribute\"].apply(get_gene_id)\n#     filtered_gtf = gtf[gtf[\"gene_id\"].isin(gene_ids)].drop(columns=[\"gene_id\"])\n\n#     # Save to new GTF file\n#     filtered_gtf.to_csv(output_gtf, sep=\"\\t\", index=False, header=False, quoting=3)\n\n#     print(f\"✅ Extracted {len(filtered_gtf)} entries for {len(gene_ids)} genes into {output_gtf}\")\n\n\n# big_gtf = \"/data/analysis/data_diamant/allos/allos/data/Mus_musculus.GRCm39.109.gtf\"\n# custom_gtf = \"/data/analysis/data_diamant/allos/allos/data/custom_subset.gtf\"\n# selected_genes = [\"ENSMUSG00000028478\", \"ENSMUSG00000025903\"]  # Replace with your genes of interest\n\n# extract_genes_from_gtf(big_gtf, custom_gtf, selected_genes)\n\n📂 Using existing extracted file: /data/analysis/data_diamant/allos/allos/data/Mus_musculus.GRCm39.109.gtf\n\n\n\n---------------------------------------------------------------------------\nPermissionError                           Traceback (most recent call last)\nCell In[23], line 5\n      2 custom_gtf = \"/data/analysis/data_diamant/allos/allos/data/custom_subset.gtf\"\n      3 selected_genes = [\"ENSMUSG00000028478\", \"ENSMUSG00000025903\"]  # Replace with your genes of interest\n----&gt; 5 extract_genes_from_gtf(big_gtf, custom_gtf, selected_genes)\n\nCell In[22], line 44, in extract_genes_from_gtf(gtf_gz_path, output_gtf, gene_ids)\n     41 filtered_gtf = gtf[gtf[\"gene_id\"].isin(gene_ids)].drop(columns=[\"gene_id\"])\n     43 # Save to new GTF file\n---&gt; 44 filtered_gtf.to_csv(output_gtf, sep=\"\\t\", index=False, header=False, quoting=3)\n     46 print(f\"✅ Extracted {len(filtered_gtf)} entries for {len(gene_ids)} genes into {output_gtf}\")\n\nFile /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/pandas/util/_decorators.py:333, in deprecate_nonkeyword_arguments.&lt;locals&gt;.decorate.&lt;locals&gt;.wrapper(*args, **kwargs)\n    327 if len(args) &gt; num_allow_args:\n    328     warnings.warn(\n    329         msg.format(arguments=_format_argument_list(allow_args)),\n    330         FutureWarning,\n    331         stacklevel=find_stack_level(),\n    332     )\n--&gt; 333 return func(*args, **kwargs)\n\nFile /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/pandas/core/generic.py:3967, in NDFrame.to_csv(self, path_or_buf, sep, na_rep, float_format, columns, header, index, index_label, mode, encoding, compression, quoting, quotechar, lineterminator, chunksize, date_format, doublequote, escapechar, decimal, errors, storage_options)\n   3956 df = self if isinstance(self, ABCDataFrame) else self.to_frame()\n   3958 formatter = DataFrameFormatter(\n   3959     frame=df,\n   3960     header=header,\n   (...)\n   3964     decimal=decimal,\n   3965 )\n-&gt; 3967 return DataFrameRenderer(formatter).to_csv(\n   3968     path_or_buf,\n   3969     lineterminator=lineterminator,\n   3970     sep=sep,\n   3971     encoding=encoding,\n   3972     errors=errors,\n   3973     compression=compression,\n   3974     quoting=quoting,\n   3975     columns=columns,\n   3976     index_label=index_label,\n   3977     mode=mode,\n   3978     chunksize=chunksize,\n   3979     quotechar=quotechar,\n   3980     date_format=date_format,\n   3981     doublequote=doublequote,\n   3982     escapechar=escapechar,\n   3983     storage_options=storage_options,\n   3984 )\n\nFile /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/pandas/io/formats/format.py:1014, in DataFrameRenderer.to_csv(self, path_or_buf, encoding, sep, columns, index_label, mode, compression, quoting, quotechar, lineterminator, chunksize, date_format, doublequote, escapechar, errors, storage_options)\n    993     created_buffer = False\n    995 csv_formatter = CSVFormatter(\n    996     path_or_buf=path_or_buf,\n    997     lineterminator=lineterminator,\n   (...)\n   1012     formatter=self.fmt,\n   1013 )\n-&gt; 1014 csv_formatter.save()\n   1016 if created_buffer:\n   1017     assert isinstance(path_or_buf, StringIO)\n\nFile /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/pandas/io/formats/csvs.py:251, in CSVFormatter.save(self)\n    247 \"\"\"\n    248 Create the writer & save.\n    249 \"\"\"\n    250 # apply compression and byte/text conversion\n--&gt; 251 with get_handle(\n    252     self.filepath_or_buffer,\n    253     self.mode,\n    254     encoding=self.encoding,\n    255     errors=self.errors,\n    256     compression=self.compression,\n    257     storage_options=self.storage_options,\n    258 ) as handles:\n    259     # Note: self.encoding is irrelevant here\n    260     self.writer = csvlib.writer(\n    261         handles.handle,\n    262         lineterminator=self.lineterminator,\n   (...)\n    267         quotechar=self.quotechar,\n    268     )\n    270     self._save()\n\nFile /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/pandas/io/common.py:873, in get_handle(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\n    868 elif isinstance(handle, str):\n    869     # Check whether the filename is to be opened in binary mode.\n    870     # Binary mode does not support 'encoding' and 'newline'.\n    871     if ioargs.encoding and \"b\" not in ioargs.mode:\n    872         # Encoding\n--&gt; 873         handle = open(\n    874             handle,\n    875             ioargs.mode,\n    876             encoding=ioargs.encoding,\n    877             errors=errors,\n    878             newline=\"\",\n    879         )\n    880     else:\n    881         # Binary mode\n    882         handle = open(handle, ioargs.mode)\n\nPermissionError: [Errno 13] Permission denied: '/data/analysis/data_diamant/allos/allos/data/custom_subset.gtf'\n\n\n\n\n# from allos.transcript_data import TranscriptData\n# td = TranscriptData(gtf_file=\"/data/analysis/data_diamant/allos/allos/data/custom_subset.gtf\")\n\n\n# td\n\n&lt;allos.transcript_data.TranscriptData&gt;\n\n\n\n# td.get_exon_coords_and_strand(\"ENSMUSG00000028478\")\n\nWARNING:root:No exons found for transcript ENSMUSG00000028478.\n\n\n([], None)\n\n\n\n# import pyranges as pr\n\n# def get_gene_coordinates_from_gtf(gtf_path, transcript_id):\n#     \"\"\"Extracts chromosome, start, and end coordinates of a gene from a GTF file using transcript ID.\"\"\"\n    \n#     # Load GTF file as pyranges object\n#     gtf = pr.read_gtf(gtf_path)\n    \n#     # Check available columns\n#     print(\"Available columns in GTF:\", gtf.columns)\n\n#     # Ensure the transcript ID column exists\n#     if \"transcript_id\" not in gtf.columns:\n#         raise ValueError(\"Column 'transcript_id' not found in GTF. Check column names.\")\n\n#     # Find the gene associated with the given transcript ID\n#     transcript_info = gtf[gtf.transcript_id == transcript_id]  # Use the correct column name\n\n#     if transcript_info.empty:\n#         raise ValueError(f\"Transcript '{transcript_id}' not found in GTF file.\")\n\n#     # Get gene ID associated with the transcript\n#     gene_id = transcript_info.gene_id.iloc[0]  # Ensure correct column name\n    \n#     # Extract gene coordinates\n#     gene_info = gtf[gtf.gene_id == gene_id]  # Ensure correct column name\n\n#     chromosome = gene_info.Chromosome.iloc[0]\n#     start = gene_info.Start.min()\n#     end = gene_info.End.max()\n\n#     return {\"gene_id\": gene_id, \"chromosome\": chromosome, \"start\": start, \"end\": end}\n\n\n# def find_tss_in_gene_range(cage_peaks_df, gene_coordinates):\n#     \"\"\"Finds CAGE TSS peaks that overlap with the gene coordinates.\"\"\"\n#     # Ensure chromosome formats match between gene_coordinates and cage_peaks_df\n#     gene_chr = gene_coordinates[\"chromosome\"]\n#     cage_chr = cage_peaks_df[\"chromosome\"].unique()\n\n#     # Check if gene_chr starts with \"chr\"\n#     if not gene_chr.startswith(\"chr\"):\n#         gene_coordinates[\"chromosome\"] = f\"chr{gene_chr}\"\n\n#     # Check if cage_peaks_df chromosomes start with \"chr\"\n#     if any(not c.startswith(\"chr\") for c in cage_chr):\n#         cage_peaks_df[\"chromosome\"] = cage_peaks_df[\"chromosome\"].apply(lambda x: f\"chr{x}\" if not x.startswith(\"chr\") else x)\n\n#     print(\"✅ Chromosome formats are now consistent!\")\n#     # Filter peaks that are in the same chromosome\n#     peaks_in_chromosome = cage_peaks_df[cage_peaks_df[\"chromosome\"] == gene_coordinates[\"chromosome\"]]\n\n#     # Ensure coordinates are integers\n#     gene_start = int(gene_coordinates[\"start\"])\n#     gene_end = int(gene_coordinates[\"end\"])\n\n#     peaks_in_chromosome[\"start\"] = peaks_in_chromosome[\"start\"].astype(int)\n#     peaks_in_chromosome[\"end\"] = peaks_in_chromosome[\"end\"].astype(int)\n\n#     # Filter peaks that overlap the gene range\n#     overlapping_peaks = peaks_in_chromosome[\n#         (peaks_in_chromosome[\"start\"] &gt;= gene_coordinates[\"start\"]) &\n#         (peaks_in_chromosome[\"end\"] &lt;= gene_coordinates[\"end\"])\n#     ]\n\n#     return overlapping_peaks\n\n\n# # Example Usage\n# gtf_path = \"/data/analysis/data_diamant/allos/allos/data/custom_subset.gtf\"\n# transcript_id = \"ENSMUST00000134384\"\n# gene_coordinates = get_gene_coordinates_from_gtf(gtf_path, \"ENSMUST00000134384\")\n# print(\"Extracted Gene Coordinates:\", gene_coordinates)\n\nAvailable columns in GTF: Index(['Chromosome', 'Source', 'Feature', 'Start', 'End', 'Score', 'Strand',\n       'Frame', 'gene_id', 'gene_version', 'gene_name', 'gene_source',\n       'gene_biotype', 'transcript_id', 'transcript_version',\n       'transcript_name', 'transcript_source', 'transcript_biotype',\n       'transcript_support_level', 'exon_number', 'exon_id', 'exon_version',\n       'protein_id', 'protein_version', 'tag', 'ccds_id'],\n      dtype='object')\nExtracted Gene Coordinates: {'gene_id': 'ENSMUSG00000025903', 'chromosome': '1', 'start': 4878010, 'end': 4918633}\n\n\n\n# cage_peaks_path = \"/data/analysis/data_diamant/allos/allos/data/refTSS_v4.1_mouse_coordinate.mm39.bed\"\n# # Load CAGE peaks as a dataframe\n# cage_peaks_df = pd.read_csv(cage_peaks_path, sep=\"\\t\", names=[\"chromosome\", \"start\", \"end\", \"refTSS_ID\", \"score\", \"strand\"])\n\n# # Get gene coordinates from GTF\n# gene_coordinates = get_gene_coordinates_from_gtf(gtf_path, transcript_id)\n\nAvailable columns in GTF: Index(['Chromosome', 'Source', 'Feature', 'Start', 'End', 'Score', 'Strand',\n       'Frame', 'gene_id', 'gene_version', 'gene_name', 'gene_source',\n       'gene_biotype', 'transcript_id', 'transcript_version',\n       'transcript_name', 'transcript_source', 'transcript_biotype',\n       'transcript_support_level', 'exon_number', 'exon_id', 'exon_version',\n       'protein_id', 'protein_version', 'tag', 'ccds_id'],\n      dtype='object')\n\n\n/tmp/ipykernel_3974226/2903875487.py:3: DtypeWarning: Columns (1,2,4) have mixed types. Specify dtype option on import or set low_memory=False.\n  cage_peaks_df = pd.read_csv(cage_peaks_path, sep=\"\\t\", names=[\"chromosome\", \"start\", \"end\", \"refTSS_ID\", \"score\", \"strand\"])\n\n\n\n# gene_coordinates\n\n{'gene_id': 'ENSMUSG00000025903',\n 'chromosome': '1',\n 'start': 4878010,\n 'end': 4918633}\n\n\n\n# find_tss_in_gene_range(cage_peaks_df, gene_coordinates)\n\n✅ Chromosome formats are now consistent!\n\n\n/tmp/ipykernel_3974226/1431948614.py:57: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  peaks_in_chromosome[\"start\"] = peaks_in_chromosome[\"start\"].astype(int)\n/tmp/ipykernel_3974226/1431948614.py:58: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  peaks_in_chromosome[\"end\"] = peaks_in_chromosome[\"end\"].astype(int)\n\n\n\n\n\n\n\n\n\nchromosome\nstart\nend\nrefTSS_ID\nscore\nstrand\n\n\n\n\n38\nchr1\n4878070\n4878151\nrfmm_38.1\n1\n+\n\n\n39\nchr1\n4878469\n4878510\nrfmm_39.1\n1\n+\n\n\n40\nchr1\n4898798\n4898839\nrfmm_40.1\n1\n+\n\n\n41\nchr1\n4915816\n4915827\nrfmm_41.1\n1\n+",
    "crumbs": [
      "Transcript plots"
    ]
  },
  {
    "objectID": "gene_report.html",
    "href": "gene_report.html",
    "title": "Gene Report Module",
    "section": "",
    "text": "class GeneReports(TranscriptPlots, AnnDataIso):\n    def __init__(self, anndata: ad.AnnData, cell_types: pd.DataFrame, palette='ghibli', gtf_file=None, reference_fasta=None):\n        AnnDataIso.__init__(self,anndata, cell_types, palette)\n        TranscriptPlots.__init__(self,gtf_file, reference_fasta)\n\n    # Plotting a summary of isoform-related metrics.\n    def plot_isoforms_summary(self):\n        \"\"\"\n        Generates a combined plot summarizing:\n        1. Percentage of genes with multiple isoforms.\n        2. Frequency distribution of isoforms per gene.\n        3. Number of genes expressed per cell type.\n\n        Returns:\n        - Combined plot saved as an image.\n        \"\"\"\n        ax1 = pw.Brick(figsize=(4, 4))\n        self._plot_switch_gen_bar(ax1)\n        ax1.set_title(\"Multiple isoforms genes %\")\n        ax2 = pw.Brick(figsize=(4, 4))\n        self._plot_isoforms_frequencies(ax2)\n        ax2.set_title(\"Frequency of isoforms per gene\")\n        ax3 = pw.Brick(figsize=(3, 2))\n        self._plot_genes_cell_type(ax3)\n        ax3.set_title(\"Nb of genes per cell type\")\n        return (ax1 | ax2 | ax3).savefig()\n\n    # Private method to create a boxplot of genes expressed per cell type.\n    def _plot_genes_cell_type(self, _ax):\n        \"\"\"\n        Plots the number of genes expressed per cell type as a boxplot.\n\n        Parameters:\n        - _ax (Axes): Matplotlib axes to render the plot.\n        \"\"\"\n        if _ax is None:\n            df = pd.DataFrame(np.transpose(self.X), columns=self.obs['cell_type'])\n            df = df.sum(axis=0).to_frame().reset_index()\n            df.columns = ['cell_type', 'n_of_genes']\n            ax = sns.boxplot(x='cell_type', y='n_of_genes', data=df)\n            ax1 = sns.stripplot(x='cell_type', y='n_of_genes', data=df, color='black', size=3)\n            ax.set_xticklabels(ax.get_xticklabels(), rotation=90)\n            plt.show()\n        else:\n            df = pd.DataFrame(np.transpose(self.X), columns=self.obs['cell_type'])\n            df = df.sum(axis=0).to_frame().reset_index()\n            df.columns = ['cell_type', 'n_of_genes']\n            sns.boxplot(x='cell_type', y='n_of_genes', data=df, ax=_ax)\n            sns.stripplot(x='cell_type', y='n_of_genes', data=df, color='black', size=3, ax=_ax)\n            _ax.set_xticklabels(_ax.get_xticklabels(), rotation=90)\n\n    def plot_genes_cell_type(self):\n        \"\"\"\n        Public method to plot the number of genes expressed per cell type.\n        \"\"\"\n        self._plot_genes_cell_type(None)\n\n    # Method to visualize isoform frequency distribution.\n    def _plot_isoforms_frequencies(self, _ax):\n        \"\"\"\n        Plots the frequency distribution of isoforms per gene.\n\n        Parameters:\n        - _ax (Axes): Matplotlib axes to render the plot.\n        \"\"\"\n        if _ax is None:\n            fig, ax = plt.subplots()\n            self.gene_counts['transcriptId'].value_counts().plot(\n                ax=ax, kind='bar', xlabel='number of isoforms per gene', ylabel='quantity of genes'\n            )\n        else:\n            self.gene_counts['transcriptId'].value_counts().plot(\n                ax=_ax, kind='bar', xlabel='number of isoforms per gene', ylabel='quantity of genes'\n            )\n\n    def plot_isoforms_frequencies(self):\n        \"\"\"\n        Public method to plot the frequency distribution of isoforms per gene.\n        \"\"\"\n        self._plot_isoforms_frequencies(None)\n\n    def plot_switch_gen_bar (self, _ax):\n        self._plot_switch_gen_bar(None)\n\n    def _plot_switch_gen_bar (self, _ax):\n        if _ax is None:\n            iso_per_gene = self.gene_counts\n            x = ['genes']\n            x1 = ['transcripts']\n            multiple_iso = sum(iso_per_gene['transcriptId'] &gt; 1)\n            mono_iso = sum((iso_per_gene['transcriptId'] &gt; 1) == False)\n            labels = [str(round(1000*multiple_iso/(multiple_iso+mono_iso))/10) + '%', str(round(1000*mono_iso/(multiple_iso+mono_iso))/10) + '%']\n            fig, ax = plt.subplots()\n            mult = ax.bar(x, multiple_iso, label=labels[1], color=self.colors[0]) #multiple_iso/(multiple_iso+mono_iso))\n            mono = ax.bar(x, mono_iso, bottom=multiple_iso, label=labels[0], color=self.colors[0]) #mona_iso/(multiple_iso+mono_iso))\n            tran = ax.bar(x1, len(self.var['transcriptId']), color=self.colors[2])\n            ax.text(\n                ax.patches[0].get_x() + ax.patches[0].get_width() / 2, ax.patches[0].get_height() / 2, labels[0], ha=\"center\", va=\"center\"\n                )\n            ax.text(\n                ax.patches[1].get_x() + ax.patches[1].get_width() / 2, ax.patches[1].get_height() / 2 + ax.patches[0].get_height(), labels[1], ha=\"center\", va=\"center\"\n                )\n            plt.legend(['Multiple isoforms', 'Single isoform'])\n            plt.show()\n        else:\n            iso_per_gene = self.gene_counts\n            x = ['genes']\n            x1 = ['transcripts']\n            multiple_iso = sum(iso_per_gene['transcriptId'] &gt; 1)\n            mono_iso = sum((iso_per_gene['transcriptId'] &gt; 1) == False)\n            labels = [str(round(1000*multiple_iso/(multiple_iso+mono_iso))/10) + '%', str(round(1000*mono_iso/(multiple_iso+mono_iso))/10) + '%']\n            mult = _ax.bar(x, multiple_iso, label=labels[1], color=self.colors[0]) #multiple_iso/(multiple_iso+mono_iso))\n            mono = _ax.bar(x, mono_iso, bottom=multiple_iso, label=labels[0], color=self.colors[1]) #mona_iso/(multiple_iso+mono_iso))\n            tran = _ax.bar(x1, len(self.var['transcriptId']), color=self.colors[2])\n            _ax.text(\n                _ax.patches[0].get_x() + _ax.patches[0].get_width() / 2, _ax.patches[0].get_height() / 2, labels[0], ha=\"center\", va=\"center\"\n                )\n            _ax.text(\n                _ax.patches[1].get_x() + _ax.patches[1].get_width() / 2, _ax.patches[1].get_height() / 2 + _ax.patches[0].get_height(), labels[1], ha=\"center\", va=\"center\"\n                )\n            _ax.legend(['Multiple isoforms', 'Single isoform'])\n            plt.show()\n\n    def _trsct_counts_cell_type (self, gene_name, trs_to_show, _ax):\n        if _ax is None:\n        # create df with filtered isoform counts and labeled cell types:\n            df = self._filtered_anndata.to_df().set_index(self._filtered_anndata.obs['cell_type'])\n            df = df.transpose()\n            df[['transcriptId', 'geneId']] = self._filtered_anndata.var[['transcriptId', 'geneId']]\n            gene_iso_count = df[df['geneId'] == gene_name]\n            gene_iso_count = gene_iso_count.drop('geneId', axis=1).set_index('transcriptId').transpose()\n            gene_iso_count_long = gene_iso_count.reset_index().melt(id_vars='cell_type', var_name='transcriptId', value_name='count')\n            if trs_to_show != []:\n                gene_iso_count_long = gene_iso_count_long[gene_iso_count_long['transcriptId'].isin(trs_to_show)]\n            g = sns.catplot(x=\"cell_type\", y=\"count\", col=\"transcriptId\", aspect=1, dodge=False, kind=\"violin\", data=gene_iso_count_long, palette=self.colors)\n            # Set custom facet titles\n            g.set_titles(col_template=\"{col_name}\", size = 8)\n            # Remove x ticks\n            g.set_xticklabels(rotation=90)\n            g.fig.suptitle(gene_name)\n            plt.show()\n        else:\n            df = self._filtered_anndata.to_df ().set_index(self._filtered_anndata.obs['cell_type'])\n            df = df.transpose()\n            df[['transcriptId', 'geneId']] = self._filtered_anndata.var[['transcriptId', 'geneId']]\n            gene_iso_count = df[df['geneId']== gene_name]\n            gene_iso_count = gene_iso_count.drop('geneId', axis=1).set_index('transcriptId').transpose()\n            gene_iso_count_long = gene_iso_count.reset_index().melt(id_vars='cell_type', var_name='transcriptId', value_name='count')\n            if trs_to_show != []:\n                gene_iso_count_long = gene_iso_count_long[gene_iso_count_long['transcriptId'].isin(trs_to_show)]\n            g = sns.catplot(x=\"cell_type\", y=\"count\", col=\"transcriptId\", aspect=1, dodge=False, kind=\"violin\", data=gene_iso_count_long, palette=self.colors)\n            # Set custom facet titles\n            g.set_titles(col_template=\"{col_name}\", size = 8)\n            # Remove x ticks\n            g.set_xticklabels(rotation=90, labels=self.obs['cell_type'].unique())\n            g.fig.suptitle(gene_name)\n            return g\n\n    def trsct_counts_cell_type (self, gene_name, trs_to_show = []):\n        # create df with filtered isoform counts and labeled cell types:\n        self._trsct_counts_cell_type(gene_name, trs_to_show, None)\n\n    def _plot_transcripts_per_cell_type(self, gene_name, trs_to_show, _ax):\n        if trs_to_show == []:\n            transcripts_id = self._get_transcripts_from_gene(gene_name)\n        else:\n            transcripts_id = trs_to_show\n        if _ax is None:\n            fig, ax = plt.subplots()\n            grouped = self._filtered_anndata.obsm['Iso_prct']\n            grouped['cell_type'] = self.obs['cell_type']\n            res = grouped.groupby('cell_type').mean().transpose()\n            res = res.assign(transcriptId=self._filtered_anndata.var['transcriptId'].to_list())\n            res = res.assign(geneId=self._filtered_anndata.var['geneId'].to_list())\n            res = res[res['geneId'] == gene_name].drop(['geneId'], axis=1)\n            res = res[res['transcriptId'].isin(transcripts_id)]\n            plot_data = res.set_index('transcriptId').transpose()\n            plot_data.plot(kind='barh', ax=ax, stacked=True, color=self.colors).legend(loc='center left',bbox_to_anchor=(1.0, 1.0))\n            plt.legend(self.get_transcripts_common_names(transcripts_id), loc=\"upper left\", bbox_to_anchor=(1, 1))\n            #plt.legend(self.get_transcripts_common_names(trs_to_show))\n            plt.ylabel('Cell type')\n        else:\n            grouped = self._filtered_anndata.obsm['Iso_prct']\n            grouped['cell_type'] = self.obs['cell_type']\n            res = grouped.groupby('cell_type').mean().transpose()\n            res = res.assign(transcriptId=self._filtered_anndata.var['transcriptId'].to_list())\n            res = res.assign(geneId=self._filtered_anndata.var['geneId'].to_list())\n            res = res[res['geneId'] == gene_name].drop(['geneId'], axis=1)\n            res = res[res['transcriptId'].isin(transcripts_id)]\n            plot_data = res.set_index('transcriptId').transpose()\n            plot_data.plot(kind='barh', stacked=True, ax=_ax, color=self.colors).legend(loc='center left',bbox_to_anchor=(1.0, 1.0))\n\n    def plot_transcripts_per_cell_type(self, gene_name, trs_to_show = []):\n        self._plot_transcripts_per_cell_type(gene_name, trs_to_show, None)\n\n    def _get_transcripts_from_gene(self, gene_name):\n        elems = self._filtered_anndata.var\n        return elems[elems['geneId'] == gene_name]['transcriptId'].to_list()\n\n    def _draw_transcripts_list_from_gene(self, gene_name, trs_to_show, _ax, colors=None):\n        if trs_to_show == []:\n            transcripts_id = self._get_transcripts_from_gene(gene_name)\n        else:\n            transcripts_id = trs_to_show\n        exons = []\n        directions = []\n        for tr in transcripts_id:\n            t, d = self._get_coord_from_tscrpt_id(tr)\n            exons += [t]\n            directions += [d]\n        if colors is None:\n            colors = []\n            for i in range(len(exons)):\n                colors.append(self.colors[i % len(self.colors)])\n        def get_limits(ex, dir):\n            start = sys.maxsize\n            end = -sys.maxsize\n            for (e, d) in zip(ex, dir):\n                if d == 1:\n                    start = min(start,e[0][1])\n                    end = max(end, e[-1][0])\n                else:\n                    start = min(start,e[-1][1])\n                    end = max(end, e[0][0])\n            return (start, end)\n        plt.axes()\n        plt.xlim((-0.1, 1.1))\n        plt.ylim((0.1 - 0.5 *  len(exons), 0.3))\n        plt.margins(0.2)\n        plt.axis('off')\n        fig = plt.gcf()\n        fig.set_size_inches(20, len(exons) * 2)\n        i = 0\n        (start, end) = get_limits(exons, directions)\n        for (ex, di, co, name) in zip(exons, directions, colors, transcripts_id):\n            self._draw_transcript(ex, di, co, name, offset= -0.5 * i, start_override=start, end_override=end, no_render=True)\n            i+=1\n        if _ax is None:\n            plt.show()\n        else:\n            return plt\n\n    def draw_transcripts_list_from_gene(self, gene_name, colors=None):\n        self._draw_transcripts_list_from_gene(gene_name, [], None, colors)\n\n    def draw_gene_summary(self, gene_name, trs_to_show = []):\n        ax1 = pw.Brick(figsize=(12,4))\n        pw.overwrite_axisgrid()\n        fg = self._trsct_counts_cell_type(gene_name, trs_to_show, ax1)\n        ax4 = pw.load_seaborngrid(fg)\n        ax1.set_title(\"Transcripts count per cell type\")\n        ax2 = pw.Brick(figsize=(12,4))\n        self._plot_transcripts_per_cell_type(gene_name, trs_to_show, ax2)\n        ax2.set_title(\"Transcripts count per cell type\")\n        ax3 = pw.Brick(figsize=(12,4))\n        self._draw_transcripts_list_from_gene(gene_name, trs_to_show, ax3)\n        ax3.set_title(\"Transcripts list\")\n        return (ax4/(ax2/ax3)).savefig()\n\n    # More detailed functions omitted for brevity.",
    "crumbs": [
      "Gene Report Module"
    ]
  },
  {
    "objectID": "switch_search.html",
    "href": "switch_search.html",
    "title": "Detecting Switches",
    "section": "",
    "text": "/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section See Also\n  else: warn(msg)\n\nsource\n\nSwitchSearch\n\n SwitchSearch (anndata:anndata._core.anndata.AnnData)\n\n*An annotated data matrix.\n.. figure:: ../_static/img/anndata_schema.svg :width: 260px :align: right :class: dark-light\n:class:~anndata.AnnData stores a data matrix :attr:X together with annotations of observations :attr:obs (:attr:obsm, :attr:obsp), variables :attr:var (:attr:varm, :attr:varp), and unstructured annotations :attr:uns.\nAn :class:~anndata.AnnData object adata can be sliced like a :class:~pandas.DataFrame, for instance adata_subset = adata[:, list_of_variable_names]. :class:~anndata.AnnData’s basic structure is similar to R’s ExpressionSet [Huber15]_. If setting an .h5ad-formatted HDF5 backing file .filename, data remains on the disk but is automatically loaded into memory if needed.*\n\nsource\n\n\nprocess_pair_wilcoxon\n\n process_pair_wilcoxon (adata_norm, cell_labels_column, group1, group2)\n\nProcess one pairwise Scanpy Wilcoxon test. Operates on a copy of adata_norm.\n\nsource\n\n\nprocess_gene_batch\n\n process_gene_batch (filtered_ss, group1, group2, cell_group_column,\n                     gene_batch)\n\nProcess a batch of gene IDs for the Dirichlet test.\n\nsource\n\n\ncompute_batch_size\n\n compute_batch_size (num_items, n_jobs)\n\nCompute a batch size that divides num_items roughly equally among n_jobs workers.\n\nsource\n\n\nchunk_list\n\n chunk_list (lst, chunk_size)\n\nYield successive chunks (batches) of chunk_size from lst.\n\nsource\n\n\ncreate_iso_adata\n\n create_iso_adata (path:str)\n\n*Creates an AnnData object containing isoform counts from a Sicelore output file.\nParameters: - path (str): Path to the input file, which is expected to be tab-separated and contain: - transcriptId: Transcript identifiers. - geneId: Gene identifiers. - Transcript counts for individual barcodes (cells) as additional columns.\nReturns: - adata_iso (AnnData): An AnnData object with isoform counts.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npath\nstr\nPath to a tab-separated file, typically the Sicelore output with transcript counts.\n\n\n\n\nfrom allos.readers_tests import *\nimport allos.preprocessing as pp\ncombined_mouse_data = process_mouse_data()\ncombined_mouse_data = pp.filter_transcripts_by_abundance(combined_mouse_data,  threshold_pct= 2)\n\n\n🔎 Looking for file at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File found at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt...\n✅ Decompression complete.\nTest data (mouse_1) downloaded successfully\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt...\n✅ Decompression complete.\nTest data (mouse_2) downloaded successfully\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/anndata/_core/anndata.py:1754: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n  utils.warn_names_duplicates(\"obs\")\n\n\n\ncombined_mouse_data.obs['cell_type'].unique()\n\narray(['mature Glutamatergic', 'Cajal-Retzius', 'imature Glutamatergic',\n       'intermediate progenitor', 'radial glia', 'cycling radial glia',\n       'imature GABAergic', 'mature GABAergic'], dtype=object)\n\n\n\nss = SwitchSearch(combined_mouse_data)\n\n\n# Run the Dirichlet–based switch test (will error if data appear log–transformed):\ndirichlet_results = ss.find_switching_isoforms_dirichlet(cell_group_column='cell_type',\n                                                         min_count=30, min_log_fold_change=1, n_jobs = 10)\n\n# Run the Wilcoxon–based switch test (will CPM–normalize and log–transform if needed):\nwilcoxon_results = ss.find_switching_isoforms_wilcoxon(cell_group_column='cell_type',\n                                                       min_fdr=0.05, min_log_fold_change=1, n_jobs = 10)\n\n/tmp/ipykernel_847531/2950237862.py:389: DeprecationWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  marker_df_filtered\n\n\n\nwilcoxon_results.sort_values(by='log_fold_change')\n\n\n\n\n\n\n\n\ntranscript_id\nscores\nlog_fold_change\npvals\npvals_adj\ngroup_1\ngroup_2\ncontrast\ngene_id\nn_cells_group_1\nn_cells_group_2\ntotal_cells\np_value\ndirection\npercent_expressed_group_1\npercent_expressed_group_2\n\n\n\n\n1104\nENSMUST00000051477.12\n3.983871\n1.313683\n6.780165e-05\n1.978236e-03\ncycling radial glia\nmature Glutamatergic\ncycling radial glia__mature Glutamatergic\nCdc42\n117\n275\n392\n1.491337e-02\n1.313683\n85.470085\n72.727273\n\n\n5019\nENSMUST00000164181.1\n4.931299\n1.337557\n8.168465e-07\n4.777785e-05\nmature GABAergic\nradial glia\nmature GABAergic__radial glia\nMyl6\n172\n68\n240\n5.727071e-04\n1.337557\n81.395349\n75.000000\n\n\n6031\nENSMUST00000050970.3\n3.715006\n1.635736\n2.031990e-04\n5.826363e-03\nmature Glutamatergic\nradial glia\nmature Glutamatergic__radial glia\nPolr1d\n275\n68\n343\n3.763291e-02\n1.635736\n77.454545\n61.764706\n\n\n6032\nENSMUST00000110557.4\n3.652179\n1.638091\n2.600250e-04\n7.239154e-03\nradial glia\nmature Glutamatergic\nmature Glutamatergic__radial glia\nPolr1d\n68\n275\n343\n4.529321e-02\n-1.638091\n79.411765\n61.818182\n\n\n1478\nENSMUST00000170241.7\n4.264503\n1.639061\n2.003471e-05\n3.617426e-03\nimature GABAergic\nimature Glutamatergic\nimature GABAergic__imature Glutamatergic\nClta\n141\n234\n375\n2.520287e-02\n1.639061\n60.283688\n45.299145\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1495\nENSMUST00000107849.9\n9.634603\n8.724378\n5.711261e-22\n2.846150e-19\nmature GABAergic\nradial glia\nmature GABAergic__radial glia\nClta\n172\n68\n240\n2.694471e-17\n8.724378\n83.139535\n7.352941\n\n\n1497\nENSMUST00000107849.9\n10.725714\n8.955872\n7.708972e-27\n4.268543e-24\nmature Glutamatergic\nradial glia\nmature Glutamatergic__radial glia\nClta\n275\n68\n343\n7.447796e-22\n8.955872\n87.636364\n7.352941\n\n\n1334\nENSMUST00000066379.10\n8.227374\n9.537246\n1.913624e-16\n4.768176e-14\nradial glia\nimature Glutamatergic\nimature Glutamatergic__radial glia\nChchd3\n68\n234\n302\n2.459492e-12\n-9.537246\n66.176471\n0.854701\n\n\n1338\nENSMUST00000066379.10\n8.379933\n9.760194\n5.295773e-17\n1.090535e-14\nradial glia\nmature Glutamatergic\nmature Glutamatergic__radial glia\nChchd3\n68\n275\n343\n6.106998e-13\n-9.760194\n66.176471\n0.727273\n\n\n2567\nENSMUST00000035038.7\n4.694975\n32.364899\n2.666390e-06\n1.221295e-04\nradial glia\nmature Glutamatergic\nmature Glutamatergic__radial glia\nFaim\n68\n275\n343\n1.323688e-03\n-32.364899\n36.764706\n0.000000\n\n\n\n\n124 rows × 16 columns\n\n\n\n\ndirichlet_results\n\n\n\n\n\n\n\n\ngene_id\ntranscript_id\ngroup_1\ngroup_2\ncontrast\np_value\nchi2_stat\nlog_fold_change\navg_usage_group_1\navg_usage_group_2\nn_cells_group_1\nn_cells_group_2\ntotal_cells\npercent_expressed_group_1\npercent_expressed_group_2\nadj_pval\n\n\n\n\n3\nClta\nENSMUST00000170241.7\nmature Glutamatergic\nintermediate progenitor\nmature Glutamatergic__intermediate progenitor\n1.050406e-07\n32.137838\n-1.300540\n0.147946\n0.543153\n275\n86\n361\n47.636364\n73.255814\n5.383331e-07\n\n\n4\nClta\nENSMUST00000107849.9\nmature Glutamatergic\nintermediate progenitor\nmature Glutamatergic__intermediate progenitor\n1.050406e-07\n32.137838\n0.723716\n0.750236\n0.363824\n275\n86\n361\n87.636364\n55.813953\n5.383331e-07\n\n\n7\nPkm\nENSMUST00000163694.3\nmature Glutamatergic\nintermediate progenitor\nmature Glutamatergic__intermediate progenitor\n2.930989e-14\n62.319359\n1.289581\n0.786460\n0.216579\n275\n86\n361\n89.818182\n51.162791\n3.004264e-13\n\n\n8\nPkm\nENSMUST00000034834.15\nmature Glutamatergic\nintermediate progenitor\nmature Glutamatergic__intermediate progenitor\n2.930989e-14\n62.319359\n-1.810307\n0.126267\n0.771793\n275\n86\n361\n42.181818\n94.186047\n3.004264e-13\n\n\n9\nSrsf3\nENSMUST00000130216.1\nmature Glutamatergic\nintermediate progenitor\nmature Glutamatergic__intermediate progenitor\n2.658153e-02\n7.255078\n0.146748\n0.881950\n0.761573\n275\n86\n361\n92.727273\n91.860465\n4.541011e-02\n\n\n10\nSrsf3\nENSMUST00000037776.14\nmature Glutamatergic\nintermediate progenitor\nmature Glutamatergic__intermediate progenitor\n2.658153e-02\n7.255078\n-1.165232\n0.052596\n0.168659\n275\n86\n361\n21.090909\n52.325581\n4.541011e-02\n\n\n11\nMyl6\nENSMUST00000218127.1\nmature Glutamatergic\nradial glia\nmature Glutamatergic__radial glia\n1.018093e-02\n9.174478\n-1.448639\n0.143715\n0.611841\n275\n68\n343\n37.818182\n89.705882\n1.897355e-02\n\n\n12\nMyl6\nENSMUST00000164181.1\nmature Glutamatergic\nradial glia\nmature Glutamatergic__radial glia\n1.018093e-02\n9.174478\n0.741052\n0.783558\n0.373453\n275\n68\n343\n89.090909\n75.000000\n1.897355e-02\n\n\n13\nTecr\nENSMUST00000019382.16\nmature Glutamatergic\nradial glia\nmature Glutamatergic__radial glia\n7.260738e-07\n28.271228\n-0.825942\n0.339977\n0.776519\n275\n68\n343\n67.636364\n91.176471\n2.480752e-06\n\n\n14\nTecr\nENSMUST00000165740.8\nmature Glutamatergic\nradial glia\nmature Glutamatergic__radial glia\n7.260738e-07\n28.271228\n1.259196\n0.580023\n0.164658\n275\n68\n343\n83.636364\n45.588235\n2.480752e-06\n\n\n15\nCdc42\nENSMUST00000030417.9\nmature Glutamatergic\ncycling radial glia\nmature Glutamatergic__cycling radial glia\n2.291634e-05\n21.367320\n1.167607\n0.589775\n0.183484\n275\n117\n392\n85.090909\n39.316239\n5.872313e-05\n\n\n16\nCdc42\nENSMUST00000051477.12\nmature Glutamatergic\ncycling radial glia\nmature Glutamatergic__cycling radial glia\n2.291634e-05\n21.367320\n-0.730720\n0.352043\n0.731046\n275\n117\n392\n72.727273\n85.470085\n5.872313e-05\n\n\n17\nClta\nENSMUST00000170241.7\nmature Glutamatergic\ncycling radial glia\nmature Glutamatergic__cycling radial glia\n4.306333e-04\n15.500507\n-1.559435\n0.147946\n0.703653\n275\n117\n392\n47.636364\n83.760684\n9.808870e-04\n\n\n18\nClta\nENSMUST00000107849.9\nmature Glutamatergic\ncycling radial glia\nmature Glutamatergic__cycling radial glia\n4.306333e-04\n15.500507\n1.310486\n0.750236\n0.202330\n275\n117\n392\n87.636364\n39.316239\n9.808870e-04\n\n\n19\nPkm\nENSMUST00000163694.3\nmature Glutamatergic\ncycling radial glia\nmature Glutamatergic__cycling radial glia\n0.000000e+00\n84.925988\n1.689738\n0.786460\n0.145154\n275\n117\n392\n89.818182\n43.589744\n0.000000e+00\n\n\n20\nPkm\nENSMUST00000034834.15\nmature Glutamatergic\ncycling radial glia\nmature Glutamatergic__cycling radial glia\n0.000000e+00\n84.925988\n-1.829145\n0.126267\n0.786470\n275\n117\n392\n42.181818\n88.888889\n0.000000e+00\n\n\n21\nPkm\nENSMUST00000163694.3\nmature Glutamatergic\nimature GABAergic\nmature Glutamatergic__imature GABAergic\n1.604636e-06\n26.685227\n0.556169\n0.786460\n0.450957\n275\n141\n416\n89.818182\n65.248227\n4.699292e-06\n\n\n22\nPkm\nENSMUST00000034834.15\nmature Glutamatergic\nimature GABAergic\nmature Glutamatergic__imature GABAergic\n1.604636e-06\n26.685227\n-1.254394\n0.126267\n0.442660\n275\n141\n416\n42.181818\n65.957447\n4.699292e-06\n\n\n25\nPkm\nENSMUST00000163694.3\nimature Glutamatergic\nintermediate progenitor\nimature Glutamatergic__intermediate progenitor\n2.830697e-07\n30.155146\n1.066032\n0.628912\n0.216579\n234\n86\n320\n84.615385\n51.162791\n1.160586e-06\n\n\n26\nPkm\nENSMUST00000034834.15\nimature Glutamatergic\nintermediate progenitor\nimature Glutamatergic__intermediate progenitor\n2.830697e-07\n30.155146\n-1.055774\n0.268524\n0.771793\n234\n86\n320\n58.974359\n94.186047\n1.160586e-06\n\n\n29\nTecr\nENSMUST00000019382.16\nimature Glutamatergic\nradial glia\nimature Glutamatergic__radial glia\n6.528992e-04\n14.668176\n-0.510518\n0.466054\n0.776519\n234\n68\n302\n71.794872\n91.176471\n1.338443e-03\n\n\n30\nTecr\nENSMUST00000165740.8\nimature Glutamatergic\nradial glia\nimature Glutamatergic__radial glia\n6.528992e-04\n14.668176\n0.963121\n0.431382\n0.164658\n234\n68\n302\n67.948718\n45.588235\n1.338443e-03\n\n\n33\nPkm\nENSMUST00000163694.3\nimature Glutamatergic\ncycling radial glia\nimature Glutamatergic__cycling radial glia\n5.309121e-09\n38.107679\n1.466188\n0.628912\n0.145154\n234\n117\n351\n84.615385\n43.589744\n3.627899e-08\n\n\n34\nPkm\nENSMUST00000034834.15\nimature Glutamatergic\ncycling radial glia\nimature Glutamatergic__cycling radial glia\n5.309121e-09\n38.107679\n-1.074612\n0.268524\n0.786470\n234\n117\n351\n58.974359\n88.888889\n3.627899e-08\n\n\n\n\n\n\n\n\nwilcoxon_results.head(20)\n\n\n\n\n\n\n\n\ntranscript_id\nscores\nlog_fold_change\npvals\npvals_adj\ngroup_1\ngroup_2\ncontrast\ngene_id\nn_cells_group_1\nn_cells_group_2\ntotal_cells\np_value\ndirection\npercent_expressed_group_1\npercent_expressed_group_2\n\n\n\n\n5893\nENSMUST00000034834.15\n12.272116\n5.359763\n1.278680e-34\n8.850244e-32\ncycling radial glia\nmature Glutamatergic\ncycling radial glia__mature Glutamatergic\nPkm\n117\n275\n392\n5.441936e-29\n5.359763\n88.888889\n42.181818\n\n\n5894\nENSMUST00000163694.3\n11.959407\n5.031865\n5.797459e-33\n3.523300e-30\nmature Glutamatergic\ncycling radial glia\ncycling radial glia__mature Glutamatergic\nPkm\n275\n117\n392\n1.645196e-27\n-5.031865\n89.818182\n43.589744\n\n\n5909\nENSMUST00000034834.15\n11.985371\n5.971428\n4.239462e-33\n2.112694e-29\nintermediate progenitor\nmature Glutamatergic\nintermediate progenitor__mature Glutamatergic\nPkm\n86\n275\n361\n8.865320e-27\n5.971428\n94.186047\n42.181818\n\n\n1477\nENSMUST00000107849.9\n11.686639\n5.032757\n1.491739e-31\n7.908438e-29\nmature Glutamatergic\ncycling radial glia\ncycling radial glia__mature Glutamatergic\nClta\n275\n117\n392\n2.994790e-26\n-5.032757\n87.636364\n39.316239\n\n\n5916\nENSMUST00000034834.15\n11.390181\n6.393306\n4.680185e-30\n4.319117e-27\nradial glia\nmature Glutamatergic\nmature Glutamatergic__radial glia\nPkm\n68\n275\n343\n1.156183e-24\n-6.393306\n95.588235\n42.181818\n\n\n5915\nENSMUST00000163694.3\n11.155944\n8.153163\n6.697808e-29\n4.768266e-26\nmature Glutamatergic\nradial glia\nmature Glutamatergic__radial glia\nPkm\n275\n68\n343\n1.039047e-23\n8.153163\n89.818182\n16.176471\n\n\n1497\nENSMUST00000107849.9\n10.725714\n8.955872\n7.708972e-27\n4.268543e-24\nmature Glutamatergic\nradial glia\nmature Glutamatergic__radial glia\nClta\n275\n68\n343\n7.447796e-22\n8.955872\n87.636364\n7.352941\n\n\n2220\nENSMUST00000154584.8\n10.593913\n6.469005\n3.180146e-26\n1.576562e-23\nradial glia\nmature Glutamatergic\nmature Glutamatergic__radial glia\nEef1d\n68\n275\n343\n2.569838e-21\n-6.469005\n89.705882\n24.727273\n\n\n5890\nENSMUST00000163694.3\n10.557364\n4.570864\n4.696683e-26\n2.600606e-23\nimature Glutamatergic\ncycling radial glia\ncycling radial glia__imature Glutamatergic\nPkm\n234\n117\n351\n4.162578e-21\n-4.570864\n84.615385\n43.589744\n\n\n1117\nENSMUST00000030417.9\n10.449820\n7.493307\n1.468039e-25\n6.773914e-23\nmature Glutamatergic\nradial glia\nmature Glutamatergic__radial glia\nCdc42\n275\n68\n343\n1.016153e-20\n7.493307\n85.090909\n14.705882\n\n\n1105\nENSMUST00000030417.9\n10.376866\n4.580756\n3.159765e-25\n8.846278e-23\nmature Glutamatergic\ncycling radial glia\ncycling radial glia__mature Glutamatergic\nCdc42\n275\n117\n392\n1.314328e-20\n-4.580756\n85.090909\n39.316239\n\n\n5905\nENSMUST00000163694.3\n10.207308\n7.692162\n1.838968e-24\n1.018257e-21\nimature Glutamatergic\nradial glia\nimature Glutamatergic__radial glia\nPkm\n234\n68\n302\n1.320205e-19\n7.692162\n84.615385\n16.176471\n\n\n1475\nENSMUST00000107849.9\n10.059887\n4.801264\n8.309374e-24\n5.049870e-21\nmature GABAergic\ncycling radial glia\ncycling radial glia__mature GABAergic\nClta\n172\n117\n289\n5.906161e-19\n-4.801264\n83.139535\n39.316239\n\n\n1473\nENSMUST00000107849.9\n9.974315\n4.474297\n1.974594e-23\n7.809675e-21\nimature Glutamatergic\ncycling radial glia\ncycling radial glia__imature Glutamatergic\nClta\n234\n117\n351\n8.932083e-19\n-4.474297\n83.760684\n39.316239\n\n\n1488\nENSMUST00000107849.9\n9.956464\n8.397410\n2.363200e-23\n1.154585e-20\nimature Glutamatergic\nradial glia\nimature Glutamatergic__radial glia\nClta\n234\n68\n302\n1.289647e-18\n8.397410\n83.760684\n7.352941\n\n\n175\nENSMUST00000044492.9\n9.735595\n6.681633\n2.125714e-22\n9.808594e-20\nimature Glutamatergic\nradial glia\nimature Glutamatergic__radial glia\nAkap9\n234\n68\n302\n9.840919e-18\n6.681633\n83.760684\n22.058824\n\n\n168\nENSMUST00000044492.9\n9.685860\n3.796590\n3.462841e-22\n1.250487e-19\nimature Glutamatergic\ncycling radial glia\ncycling radial glia__imature Glutamatergic\nAkap9\n234\n117\n351\n1.232702e-17\n-3.796590\n83.760684\n50.427350\n\n\n6923\nENSMUST00000102843.9\n9.674722\n4.648714\n3.861395e-22\n1.374491e-19\nmature Glutamatergic\nradial glia\nmature Glutamatergic__radial glia\nRtn4\n275\n68\n343\n1.342160e-17\n4.648714\n88.000000\n47.058824\n\n\n1495\nENSMUST00000107849.9\n9.634603\n8.724378\n5.711261e-22\n2.846150e-19\nmature GABAergic\nradial glia\nmature GABAergic__radial glia\nClta\n172\n68\n240\n2.694471e-17\n8.724378\n83.139535\n7.352941\n\n\n5914\nENSMUST00000034834.15\n9.559292\n5.820885\n1.185652e-21\n5.681323e-19\nradial glia\nmature GABAergic\nmature GABAergic__radial glia\nPkm\n68\n172\n240\n5.196361e-17\n-5.820885\n95.588235\n43.023256\n\n\n\n\n\n\n\n\nimport allos.visuals as vs\nsc.pp.normalize_total(combined_mouse_data, target_sum=1e6)\nsc.pp.log1p(combined_mouse_data)\nsc.pp.neighbors(combined_mouse_data)\nsc.tl.umap(combined_mouse_data)\nsc.pl.umap(combined_mouse_data, color = 'cell_type')\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/scanpy/tools/_utils.py:41: UserWarning: You’re trying to run this on 24917 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n  warnings.warn(\n\n\n\n\n\n\n\n\n\n\nvs.plot_transcripts(combined_mouse_data, gene_id='Pkm')\n\n\n\n\n\n\n\n\n\nPkm_Txs = combined_mouse_data[:, combined_mouse_data.var['geneId'] =='Pkm'].var.index.to_list()\n\n\nvs.plot_density_multi(combined_mouse_data, features=Pkm_Txs)\n\n\n\n\n\n\n\n\n\nvs.plot_transcripts(combined_mouse_data, gene_id='Cdc42')\n\n\n\n\n\n\n\n\n\nEef1d_Txs = combined_mouse_data[:, combined_mouse_data.var['geneId'] =='Cdc42'].var.index.to_list()\nvs.plot_density_multi(combined_mouse_data, features=Eef1d_Txs)\n\n\n\n\n\n\n\n\n\nvs.plot_transcript_exspression_dotplot(combined_mouse_data, gene_id= 'Cdc42', top_n=2)\n\n\n\n\n\n\n\n\n\nvs.plot_transcript_expression_violin(combined_mouse_data, gene_id= 'Cdc42', top_n=2)\n\n\n\n\n\n\n\n\n\nimport os\nimport urllib.request\nfrom pathlib import Path\n\n# Example Ensembl URLs for mouse GRCm39 (release 109)\ngtf_url = \"ftp://ftp.ensembl.org/pub/release-109/gtf/mus_musculus/Mus_musculus.GRCm39.109.gtf.gz\"\nfasta_url = \"ftp://ftp.ensembl.org/pub/release-109/fasta/mus_musculus/dna/Mus_musculus.GRCm39.dna.primary_assembly.fa.gz\"\n\n# Store data one directory back\ndata_dir = Path(\"..\") / \"data\"\ndata_dir.mkdir(parents=True, exist_ok=True)\n\ngtf_file_local = data_dir / \"Mus_musculus.GRCm39.109.gtf.gz\"\nfasta_file_local = data_dir / \"Mus_musculus.GRCm39.dna.primary_assembly.fa.gz\"\n\n# Download if not already present\nif not gtf_file_local.is_file():\n    print(f\"Downloading {gtf_url}...\")\n    urllib.request.urlretrieve(gtf_url, gtf_file_local)\n\nif not fasta_file_local.is_file():\n    print(f\"Downloading {fasta_url}...\")\n    urllib.request.urlretrieve(fasta_url, fasta_file_local)\n\n\nsource\n\n\nget_top_n_isoforms\n\n get_top_n_isoforms (adata, gene_id, top_n=5, strip=False)\n\n*Get the top_n transcript IDs for a given gene based on overall average expression.\nParameters: - adata: AnnData object containing transcript-level data. - gene_id: The gene ID to search for corresponding isoforms. - top_n: The number of top isoforms to return based on overall average expression. - strip: Boolean indicating whether to strip the dot and everything after from the ID.\nReturns: - A list of top_n transcript IDs.*\n\ntop_n = get_top_n_isoforms(combined_mouse_data,  gene_id= 'Cdc42', top_n=2, strip = True)\n\n\ntop_n\n\n['ENSMUST00000051477', 'ENSMUST00000030417']\n\n\n\nfrom allos.color_palette import ghibli\nfrom allos.transcript_plots import TranscriptPlots\n\ntp = TranscriptPlots(gtf_file=gtf_file_local)\n\ntp.draw_transcripts_list(['ENSMUST00000051477', 'ENSMUST00000030417'], colors=ghibli,  draw_cds=True)\n\n\n\n\n\n\n\n\n\ncombined_mouse_data\n\nAnnData object with n_obs × n_vars = 1109 × 24917\n    obs: 'batch', 'cell_type'\n    var: 'geneId'\n    uns: 'log1p', 'pca', 'neighbors', 'umap', 'cell_type_colors'\n    obsm: 'X_pca', 'X_umap'\n    varm: 'PCs'\n    obsp: 'distances', 'connectivities'",
    "crumbs": [
      "Detecting Switches"
    ]
  },
  {
    "objectID": "transcript_data.html",
    "href": "transcript_data.html",
    "title": "Transcript Data",
    "section": "",
    "text": "source\n\nTranscriptData\n\n TranscriptData (gtf_file:str, reference_fasta:Optional[str]=None)\n\n*A class for managing transcript and gene information from a GTF file using PyRanges.\nExisting Features: - Lookup by transcript ID or gene ID/name - Support for exons, CDS, UTR queries - Intron coordinate calculation - Batch queries - Transcript length calculation - Caching/memoization for repeated queries - Basic logging/error handling\nNEW Features: (1) Nucleotide/protein sequence retrieval for CDS (with optional FASTA) (2) Alternative splicing analysis with splice junctions, isoform comparisons, and junction-chain interpretation.*\n\nimport os\nimport urllib.request\nfrom pathlib import Path\n\n# Example Ensembl URLs for mouse GRCm39 (release 109)\ngtf_url = \"ftp://ftp.ensembl.org/pub/release-109/gtf/mus_musculus/Mus_musculus.GRCm39.109.gtf.gz\"\nfasta_url = \"ftp://ftp.ensembl.org/pub/release-109/fasta/mus_musculus/dna/Mus_musculus.GRCm39.dna.primary_assembly.fa.gz\"\n\n# Store data one directory back\ndata_dir = Path(\"..\") / \"data\"\ndata_dir.mkdir(parents=True, exist_ok=True)\n\ngtf_file_local = data_dir / \"Mus_musculus.GRCm39.109.gtf.gz\"\nfasta_file_local = data_dir / \"Mus_musculus.GRCm39.dna.primary_assembly.fa.gz\"\n\n# Download if not already present\nif not gtf_file_local.is_file():\n    print(f\"Downloading {gtf_url}...\")\n    urllib.request.urlretrieve(gtf_url, gtf_file_local)\n\nif not fasta_file_local.is_file():\n    print(f\"Downloading {fasta_url}...\")\n    urllib.request.urlretrieve(fasta_url, fasta_file_local)\n\n# Instantiate your TranscriptData\ntd = TranscriptData(\n    gtf_file=gtf_file_local,\n    reference_fasta=fasta_file_local\n)\n\n# Now you can make queries like:\nexample_transcript_id = \"ENSMUST00000070533\"  # e.g., for mouse\nexons = td.get_exons(example_transcript_id)\nprint(\"Exons:\", exons)\n\nExons: +--------------+----------------+------------+-----------+-----------+------------+--------------+------------+--------------------+----------------+-------------+----------------+----------------+--------------------+----------------------+-------------------+---------------------+----------------------+-------------------+------------------------------------+---------------+--------------------+----------------+------------+-------+\n|   Chromosome | Source         | Feature    |     Start |       End | Score      | Strand       | Frame      | gene_id            |   gene_version | gene_name   | gene_source    | gene_biotype   | transcript_id      |   transcript_version | transcript_name   | transcript_source   | transcript_biotype   | tag               | transcript_support_level           |   exon_number | exon_id            |   exon_version | ccds_id    | +2    |\n|   (category) | (object)       | (object)   |   (int64) |   (int64) | (object)   | (category)   | (object)   | (object)           |       (object) | (object)    | (object)       | (object)       | (object)           |             (object) | (object)          | (object)            | (object)             | (object)          | (object)                           |      (object) | (object)           |       (object) | (object)   | ...   |\n|--------------+----------------+------------+-----------+-----------+------------+--------------+------------+--------------------+----------------+-------------+----------------+----------------+--------------------+----------------------+-------------------+---------------------+----------------------+-------------------+------------------------------------+---------------+--------------------+----------------+------------+-------|\n|            1 | ensembl_havana | exon       |   3740774 |   3741721 | .          | -            | .          | ENSMUSG00000051951 |              6 | Xkr4        | ensembl_havana | protein_coding | ENSMUST00000070533 |                    5 | Xkr4-201          | ensembl_havana      | protein_coding       | Ensembl_canonical | 1 (assigned to previous version 4) |             1 | ENSMUSE00000485541 |              4 | CCDS14803  | ...   |\n|            1 | ensembl_havana | exon       |   3491924 |   3492124 | .          | -            | .          | ENSMUSG00000051951 |              6 | Xkr4        | ensembl_havana | protein_coding | ENSMUST00000070533 |                    5 | Xkr4-201          | ensembl_havana      | protein_coding       | Ensembl_canonical | 1 (assigned to previous version 4) |             2 | ENSMUSE00000449517 |              4 | CCDS14803  | ...   |\n|            1 | ensembl_havana | exon       |   3284704 |   3287191 | .          | -            | .          | ENSMUSG00000051951 |              6 | Xkr4        | ensembl_havana | protein_coding | ENSMUST00000070533 |                    5 | Xkr4-201          | ensembl_havana      | protein_coding       | Ensembl_canonical | 1 (assigned to previous version 4) |             3 | ENSMUSE00000448840 |              3 | CCDS14803  | ...   |\n+--------------+----------------+------------+-----------+-----------+------------+--------------+------------+--------------------+----------------+-------------+----------------+----------------+--------------------+----------------------+-------------------+---------------------+----------------------+-------------------+------------------------------------+---------------+--------------------+----------------+------------+-------+\nStranded PyRanges object has 3 rows and 26 columns from 1 chromosomes.\nFor printing, the PyRanges was sorted on Chromosome and Strand.\n2 hidden columns: protein_id, protein_version\n\n\n\nranges = pr.read_gtf(gtf_file_local)\n\n\nranges.columns\n\nIndex(['Chromosome', 'Source', 'Feature', 'Start', 'End', 'Score', 'Strand',\n       'Frame', 'gene_id', 'gene_version', 'gene_name', 'gene_source',\n       'gene_biotype', 'transcript_id', 'transcript_version',\n       'transcript_name', 'transcript_source', 'transcript_biotype', 'tag',\n       'transcript_support_level', 'exon_number', 'exon_id', 'exon_version',\n       'ccds_id', 'protein_id', 'protein_version'],\n      dtype='object')\n\n\n\nranges.as_df()['transcript_id']\n\n0                         NaN\n1          ENSMUST00000194081\n2          ENSMUST00000194081\n3                         NaN\n4          ENSMUST00000194393\n                  ...        \n1901233    ENSMUST00000189418\n1901234    ENSMUST00000189418\n1901235                   NaN\n1901236    ENSMUST00000186353\n1901237    ENSMUST00000186353\nName: transcript_id, Length: 1901238, dtype: object\n\n\n\nfrom allos.readers_tests import *\nmouse_data = process_mouse_data()\n\n\n🔎 Looking for file at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File found at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt...\n✅ Decompression complete.\nTest data (mouse_1) downloaded successfully\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt...\n✅ Decompression complete.\nTest data (mouse_2) downloaded successfully\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/anndata/_core/anndata.py:1754: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n  utils.warn_names_duplicates(\"obs\")\n\n\n\ntranscriptIds = mouse_data.var.index.to_list()\n\n\ntranscriptIds[:10]\n\n['ENSMUST00000156717.1',\n 'ENSMUST00000212520.1',\n 'ENSMUST00000025798.12',\n 'ENSMUST00000231280.1',\n 'ENSMUST00000039286.4',\n 'ENSMUST00000144552.7',\n 'ENSMUST00000112304.8',\n 'ENSMUST00000162041.7',\n 'ENSMUST00000053506.6',\n 'ENSMUST00000028207.12']\n\n\n\ngene_names = td.get_gene_names_for_transcripts(transcript_ids=transcriptIds)\n\n\ngene_names[:10]\n\n['Klc2',\n 'Capn15',\n 'Klc2',\n 'Eva1c',\n 'Atg5',\n 'Znhit3',\n 'Ppm1b',\n 'Gcc2',\n 'Bbs1',\n 'Crat']",
    "crumbs": [
      "Transcript Data"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Allos",
    "section": "",
    "text": "Allos_logo\nSingle-cell RNA sequencing (scRNA-seq) has revolutionized our understanding of cellular diversity by allowing the study of gene expression at the individual cell level. However, traditional methods of quantification obscure the most fine-grained transcriptional layer—the individual transcripts at sequence-level resolution—in favor of gene-level binning. This strategy is useful when the sequencing read length is short, as it avoids the difficult task of transcript assembly, which is made even more challenging by the nature of single-cell data.\nTraditional scRNA-seq methods often rely on short-read sequencing technologies, which can limit the ability to resolve full-length transcripts and isoforms. Long-read sequencing technologies, such as those provided by Oxford Nanopore and PacBio, overcome this limitation by producing reads that span entire transcripts. This capability is crucial for accurately identifying and characterizing novel isoforms and understanding the complexity of transcriptomes in single cells. By integrating long-read sequencing with single-cell approaches, researchers can gain deeper insights into cellular heterogeneity and the functional implications of transcriptomic variations.\nAllos is designed to give users familiar with single-cell analysis, and indeed object-oriented programming in general, an extended toolkit wrapping around Scanpy and the wider scverse to facilitate analysis workflows of this type of data. Allos is the culmination of many smaller individualized scripts packaged together into a common framework centered on anndata objects. It also contains many recreations (of varying faithfulness to their originals*) of functions proposed by others in other libraries, languages, or contexts—we by no means intend to plagiarize these methods but only expand them to a wider audience.\nAllos intends to offer a full suite of modules for every step of single-cell isoform resolution data, from preprocessing, working with annotations, plotting, identifying differential features, isoform switches, and more. We hope to expand Allos with the input of our user base as the field of long-read single-cell further matures.",
    "crumbs": [
      "Allos"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "Allos",
    "section": "Install",
    "text": "Install\npip install allos",
    "crumbs": [
      "Allos"
    ]
  },
  {
    "objectID": "index.html#basic-workflow",
    "href": "index.html#basic-workflow",
    "title": "Allos",
    "section": "Basic workflow",
    "text": "Basic workflow\nThe first thing we need to work with Allos is data. Our goal is for Allos to handle many, if not all, types of single-cell isoform resolution data, making it platform and protocol agnostic. While it is important to consider the biases, strengths, limitations, and caveats of each approach, all methods utilize a transcript matrix from which a gene matrix can be derived. Allos also allows users to supply their own custom annotations in the form of a GTF or use a reference annotation. If a reference annotation is provided, all plotting functions will use the underlying GTF to retrieve the transcript information.\nTo help you follow the basic workflow, we provide an easy way to download one of our test datasets. The Sicelore dataset comprises 1,121 single-cell transcriptomes from two technical replicates derived from an embryonic day 18 (E18) mouse brain, consisting of 951 cells and 190 cells. The dataset was generated using the 10x Genomics Chromium system and sequenced with both Oxford Nanopore and Illumina platforms, producing 322 million Nanopore reads and 70 million Illumina reads for the 951-cell replicate, and 32 million Nanopore reads with 43 million Illumina reads for the 190-cell replicate. The dataset captured a median of 2,427 genes and 6,047 UMIs per cell, enabling the identification of 33,002 annotated transcript isoforms and 4,388 novel isoforms. Major cell types in the dataset include radial glia, cycling radial glia, intermediate progenitors, Cajal-Retzius cells, and maturing GABAergic and glutamatergic neurons, providing a detailed resource for studying transcriptome-wide alternative splicing, isoform expression, and sequence diversity during mouse brain development.\n\nimport allos.preprocessing as pp\nsicelore_mouse_data = pp.process_mouse_data()\n\n\n🔎 Looking for file at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File found at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt...\n✅ Decompression complete.\nTest data (mouse_1) downloaded successfully\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt...\n✅ Decompression complete.\nTest data (mouse_2) downloaded successfully\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/anndata/_core/anndata.py:1754: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n  utils.warn_names_duplicates(\"obs\")\n\n\nIn this dataset, we observe the mouse data organized in a cell-by-transcript matrix format. This structure allows us to examine the expression levels of individual transcripts across different cells. Additionally, each transcript is associated with a specific gene, providing a hierarchical view of gene expression. This organization is crucial for understanding the relationship between transcripts and their corresponding genes.\n\nsicelore_mouse_data\n\nView of AnnData object with n_obs × n_vars = 1109 × 31986\n    obs: 'batch', 'cell_type'\n    var: 'geneId'\n\n\n\nprint(sicelore_mouse_data.var.head(10))\n\n                       geneId\ntranscriptId                 \nENSMUST00000156717.1     Klc2\nENSMUST00000212520.1   Capn15\nENSMUST00000025798.12    Klc2\nENSMUST00000231280.1    Eva1c\nENSMUST00000039286.4     Atg5\nENSMUST00000144552.7   Znhit3\nENSMUST00000112304.8    Ppm1b\nENSMUST00000162041.7     Gcc2\nENSMUST00000053506.6     Bbs1\nENSMUST00000028207.12    Crat\n\n\nIsoAdata objects are fully compatible with standard AnnData objects. We can use them just like any conventional AnnData instance. Let’s take a closer look at how they function.\n\nimport scanpy as sc\n\n# Make a copy of the original data to preserve it\noriginal_sicelore_mouse_data = sicelore_mouse_data.copy()\n\n# Perform the operations\nsc.pp.normalize_total(sicelore_mouse_data, target_sum=1e6)\nsc.pp.log1p(sicelore_mouse_data)\n\n# Select the top 5000 highly variable genes\nsc.pp.highly_variable_genes(sicelore_mouse_data, n_top_genes=5000)\nsicelore_mouse_data = sicelore_mouse_data[:, sicelore_mouse_data.var.highly_variable]\n\nsc.pp.neighbors(sicelore_mouse_data)\nsc.tl.umap(sicelore_mouse_data)\nsc.pl.umap(sicelore_mouse_data, color='cell_type')\n\n# Restore the original data\nsicelore_mouse_data = original_sicelore_mouse_data\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/scanpy/preprocessing/_normalization.py:207: UserWarning: Received a view of an AnnData. Making a copy.\n  view_to_actual(adata)\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/scanpy/tools/_utils.py:41: UserWarning: You’re trying to run this on 5000 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n  warnings.warn(\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n\n\n\n\n\n\n\n\n\nWe can easily collapse the transcript matrix to a gene matrix and see how the dimensionality reduction plot differs.\n\nimport allos.preprocessing as pp\n\ngene_anndata = pp.get_sot_gene_matrix(sicelore_mouse_data)\n\n# Make a copy of the gene matrix data to preserve it\noriginal_gene_anndata = gene_anndata.copy()\n\n# Perform the operations on the gene matrix\nsc.pp.normalize_total(gene_anndata, target_sum=1e6)\nsc.pp.log1p(gene_anndata)\n\n# Select the top 5000 highly variable genes for gene_anndata\nsc.pp.highly_variable_genes(gene_anndata, n_top_genes=2000)\ngene_anndata = gene_anndata[:, gene_anndata.var.highly_variable]\n\nsc.pp.neighbors(gene_anndata)\nsc.tl.umap(gene_anndata)\nsc.pl.umap(gene_anndata, color='cell_type')\n\n# Restore the original gene matrix data\ngene_anndata = original_gene_anndata\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/scanpy/tools/_utils.py:41: UserWarning: You’re trying to run this on 2014 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n  warnings.warn(\n\n\n\n\n\n\n\n\n\nLet’s examine the most differentially expressed genes across the pre-annotated cell types.\n\nsc.pp.normalize_total(gene_anndata, target_sum=1e6)\nsc.pp.log1p(gene_anndata)\n# Perform differential expression analysis to rank genes on the gene matrix\nsc.tl.rank_genes_groups(gene_anndata, 'cell_type', method='t-test')\n\n# Plot the ranked gene groups with adjusted figure size\nsc.pl.rank_genes_groups(gene_anndata, n_genes=20, sharey=False, figsize=(12, 10))\n\nsc.pl.rank_genes_groups_heatmap(gene_anndata, show_gene_labels=True)\n\n\n\n\n\n\n\n\nWARNING: dendrogram data not found (using key=dendrogram_cell_type). Running `sc.tl.dendrogram` with default parameters. For fine tuning it is recommended to run `sc.tl.dendrogram` independently.\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/scanpy/tools/_utils.py:41: UserWarning: You’re trying to run this on 12561 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n  warnings.warn(\n\n\n\n\n\n\n\n\n\nNow, let’s examine the differentially expressed transcripts. Unlike our previous focus on genes, we will shift our attention to the transcript level. The finest resoloution transcriptional layer. We should still see considerable gene wise overlap in the two rankings as we would expect in many cases the higher gene count to be driven by a single isoform.\n\n# Concatenate the gene name before the transcript ID in the transcript matrix\ntranscript_matrix = sicelore_mouse_data.copy()\n\n# Convert 'geneId' to string to avoid TypeError when concatenating with index\ntranscript_matrix.var['geneId'] = transcript_matrix.var['geneId'].astype(str)\n\n# Assuming 'gene_name' and 'transcript_id' are columns in the var DataFrame of the AnnData object\ntranscript_matrix.var['gene_transcript_id'] = transcript_matrix.var['geneId'] + '_' + transcript_matrix.var.index.astype(str)\n\n# Truncate the gene_transcript_id to fit better in plots\ntranscript_matrix.var['gene_transcript_id'] = transcript_matrix.var['gene_transcript_id'].str.slice(0, 20)\n\n# Update the var index to use the new truncated gene_transcript_id\ntranscript_matrix.var.index = transcript_matrix.var['gene_transcript_id']\n\ntranscript_matrix.var_names_make_unique()\n\n# Log transform and CPM normalize the transcript matrix\nsc.pp.normalize_total(transcript_matrix, target_sum=1e6)\nsc.pp.log1p(transcript_matrix)\n\n# Perform differential expression analysis to rank genes on the transcript matrix\nsc.tl.rank_genes_groups(transcript_matrix, 'cell_type', method='t-test')\n\n# Plot the ranked gene groups with adjusted figure size\nsc.pl.rank_genes_groups(transcript_matrix, n_genes=20, sharey=False, figsize=(12, 10))\n\nsc.pl.rank_genes_groups_heatmap(transcript_matrix, show_gene_labels=True)\n\n\n\n\n\n\n\n\nWARNING: dendrogram data not found (using key=dendrogram_cell_type). Running `sc.tl.dendrogram` with default parameters. For fine tuning it is recommended to run `sc.tl.dendrogram` independently.\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/scanpy/tools/_utils.py:41: UserWarning: You’re trying to run this on 31986 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n  warnings.warn(\n\n\n\n\n\n\n\n\n\nLets visualise the isoforms of a specific gene Nnat based on multiple transcripts from this gene in the top rankings of imature GABAergic vs rest.\n\n# Perform the operations on a copy of the sicelore_mouse_data\nsicelore_mouse_data_copy = sicelore_mouse_data.copy()\n\nsc.pp.normalize_total(sicelore_mouse_data_copy, target_sum=1e6)\nsc.pp.log1p(sicelore_mouse_data_copy)\n\nsc.pp.neighbors(sicelore_mouse_data_copy)\nsc.tl.umap(sicelore_mouse_data_copy)\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/scanpy/tools/_utils.py:41: UserWarning: You’re trying to run this on 31986 dimensions of `.X`, if you really want this, set `use_rep='X'`.\n         Falling back to preprocessing with `sc.pp.pca` and default params.\n  warnings.warn(\n\n\n\nimport allos.visuals as vs\nvs.plot_transcripts(sicelore_mouse_data_copy, gene_id='Nnat')\n\n\n\n\n\n\n\n\n\nimport allos.visuals as vs\nvs.plot_transcripts(sicelore_mouse_data_copy, gene_id='Pkm')\n\n\n\n\n\n\n\n\n\nfrom allos.switch_search import SwitchSearch\n\n\nss = SwitchSearch(sicelore_mouse_data)\n\n\nswitch_list = ss.find_switching_isoforms_wilcoxon(n_jobs=10)\n\n\nswitch_list.head(20)\n\n\n\n\n\n\n\n\ntranscript_id\nscores\nlog_fold_change\npvals\npvals_adj\ngroup_1\ngroup_2\ncontrast\ngene_id\nn_cells_group_1\nn_cells_group_2\ntotal_cells\np_value\ndirection\npercent_expressed_group_1\npercent_expressed_group_2\n\n\n\n\n5943\nENSMUST00000034834.15\n12.270655\n5.354527\n1.301969e-34\n1.156799e-31\ncycling radial glia\nmature Glutamatergic\ncycling radial glia__mature Glutamatergic\nPkm\n117\n275\n392\n7.113057e-29\n5.354527\n88.888889\n42.181818\n\n\n5944\nENSMUST00000163694.3\n11.957458\n5.027552\n5.935075e-33\n4.630227e-30\nmature Glutamatergic\ncycling radial glia\ncycling radial glia__mature Glutamatergic\nPkm\n275\n117\n392\n2.160587e-27\n-5.027552\n89.818182\n43.589744\n\n\n5959\nENSMUST00000034834.15\n11.984186\n5.965338\n4.300464e-33\n2.751093e-29\nintermediate progenitor\nmature Glutamatergic\nintermediate progenitor__mature Glutamatergic\nPkm\n86\n275\n361\n1.154418e-26\n5.965338\n94.186047\n42.181818\n\n\n1486\nENSMUST00000107849.9\n11.684690\n5.028407\n1.526343e-31\n1.038757e-28\nmature Glutamatergic\ncycling radial glia\ncycling radial glia__mature Glutamatergic\nClta\n275\n117\n392\n3.982160e-26\n-5.028407\n87.636364\n39.316239\n\n\n5966\nENSMUST00000034834.15\n11.383351\n6.386945\n5.061634e-30\n5.996349e-27\nradial glia\nmature Glutamatergic\nmature Glutamatergic__radial glia\nPkm\n68\n275\n343\n1.591441e-24\n-6.386945\n95.588235\n42.181818\n\n\n5965\nENSMUST00000163694.3\n11.155944\n8.147258\n6.697808e-29\n6.121031e-26\nmature Glutamatergic\nradial glia\nmature Glutamatergic__radial glia\nPkm\n275\n68\n343\n1.333826e-23\n8.147258\n89.818182\n16.176471\n\n\n1506\nENSMUST00000107849.9\n10.725714\n8.949328\n7.708972e-27\n5.360417e-24\nmature Glutamatergic\nradial glia\nmature Glutamatergic__radial glia\nClta\n275\n68\n343\n9.377558e-22\n8.949328\n87.636364\n7.352941\n\n\n2235\nENSMUST00000154584.8\n10.596644\n6.462344\n3.088641e-26\n1.975866e-23\nradial glia\nmature Glutamatergic\nmature Glutamatergic__radial glia\nEef1d\n68\n275\n343\n3.237709e-21\n-6.462344\n89.705882\n24.727273\n\n\n5940\nENSMUST00000163694.3\n10.560711\n4.567454\n4.532153e-26\n3.221454e-23\nimature Glutamatergic\ncycling radial glia\ncycling radial glia__imature Glutamatergic\nPkm\n234\n117\n351\n5.183036e-21\n-4.567454\n84.615385\n43.589744\n\n\n1130\nENSMUST00000030417.9\n10.449820\n7.487224\n1.468039e-25\n8.695686e-23\nmature Glutamatergic\nradial glia\nmature Glutamatergic__radial glia\nCdc42\n275\n68\n343\n1.304437e-20\n7.487224\n85.090909\n14.705882\n\n\n1118\nENSMUST00000030417.9\n10.378815\n4.576591\n3.095947e-25\n1.112662e-22\nmature Glutamatergic\ncycling radial glia\ncycling radial glia__mature Glutamatergic\nCdc42\n275\n117\n392\n1.657093e-20\n-4.576591\n85.090909\n39.316239\n\n\n5955\nENSMUST00000163694.3\n10.207308\n7.687160\n1.838968e-24\n1.307138e-21\nimature Glutamatergic\nradial glia\nimature Glutamatergic__radial glia\nPkm\n234\n68\n302\n1.694750e-19\n7.687160\n84.615385\n16.176471\n\n\n1484\nENSMUST00000107849.9\n10.054152\n4.796204\n8.807723e-24\n6.871313e-21\nmature GABAergic\ncycling radial glia\ncycling radial glia__mature GABAergic\nClta\n172\n117\n289\n8.006304e-19\n-4.796204\n83.139535\n39.316239\n\n\n1482\nENSMUST00000107849.9\n9.975988\n4.470673\n1.941579e-23\n9.857674e-21\nimature Glutamatergic\ncycling radial glia\ncycling radial glia__imature Glutamatergic\nClta\n234\n117\n351\n1.127442e-18\n-4.470673\n83.760684\n39.316239\n\n\n1497\nENSMUST00000107849.9\n9.958041\n8.391595\n2.326005e-23\n1.458816e-20\nimature Glutamatergic\nradial glia\nimature Glutamatergic__radial glia\nClta\n234\n68\n302\n1.632402e-18\n8.391595\n83.760684\n7.352941\n\n\n182\nENSMUST00000044492.9\n9.737172\n6.676501\n2.092979e-22\n1.239741e-19\nimature Glutamatergic\nradial glia\nimature Glutamatergic__radial glia\nAkap9\n234\n68\n302\n1.251917e-17\n6.676501\n83.760684\n22.058824\n\n\n1504\nENSMUST00000107849.9\n9.634603\n8.717126\n5.711261e-22\n3.653608e-19\nmature GABAergic\nradial glia\nmature GABAergic__radial glia\nClta\n172\n68\n240\n3.464178e-17\n8.717126\n83.139535\n7.352941\n\n\n5964\nENSMUST00000034834.15\n9.557229\n5.815203\n1.209522e-21\n7.439957e-19\nradial glia\nmature GABAergic\nmature GABAergic__radial glia\nPkm\n68\n172\n240\n6.804876e-17\n-5.815203\n95.588235\n43.023256\n\n\n1485\nENSMUST00000170241.7\n9.399286\n3.665712\n5.493450e-21\n1.417044e-18\ncycling radial glia\nmature Glutamatergic\ncycling radial glia__mature Glutamatergic\nClta\n117\n275\n392\n1.266246e-16\n3.665712\n83.760684\n47.636364\n\n\n1507\nENSMUST00000170241.7\n9.359902\n4.369593\n7.981022e-21\n3.191012e-18\nradial glia\nmature Glutamatergic\nmature Glutamatergic__radial glia\nClta\n68\n275\n343\n2.733443e-16\n-4.369593\n89.705882\n47.636364\n\n\n\n\n\n\n\n\nvs.plot_transcript_exspression_dotplot(sicelore_mouse_data_copy, gene_id='Clta')\n\n\n\n\n\n\n\n\n\nvs.plot_transcript_expression_violin(sicelore_mouse_data_copy, gene_id='Clta')\n\n\n\n\n\n\n\n\n\nvs.plot_transcript_exspression_dotplot(sicelore_mouse_data_copy, gene_id='Akap9')\n\n\n\n\n\n\n\n\n\nimport os\nimport urllib.request\nfrom pathlib import Path\n\n# Example Ensembl URLs for mouse GRCm39 (release 109)\ngtf_url = \"ftp://ftp.ensembl.org/pub/release-109/gtf/mus_musculus/Mus_musculus.GRCm39.109.gtf.gz\"\n\n# Store data one directory back\ndata_dir = Path(\"..\") / \"data\"\ndata_dir.mkdir(parents=True, exist_ok=True)\n\ngtf_file_local = data_dir / \"Mus_musculus.GRCm39.109.gtf.gz\"\n\n# Download if not already present\nif not gtf_file_local.is_file():\n    print(f\"Downloading {gtf_url}...\")\n    urllib.request.urlretrieve(gtf_url, gtf_file_local)\n\n\nfrom allos.transcript_plots import TranscriptPlots\n\ntp = TranscriptPlots(gtf_file= gtf_file_local)\n\n\nfrom allos.switch_search import get_top_n_isoforms\n\n\ntop_n = get_top_n_isoforms(sicelore_mouse_data_copy, gene_id='Akap9', strip=True)\ntp.draw_transcripts_list(top_n, draw_cds=True)\n\nWARNING:root:No CDS features found for transcript ENSMUST00000141817.\nWARNING:root:No CDS features found for transcript ENSMUST00000177448.\n\n\n\ntop_n\n\n['ENSMUST00000044492',\n 'ENSMUST00000143365',\n 'ENSMUST00000141817',\n 'ENSMUST00000177448',\n 'ENSMUST00000132058']\n\n\n\ntop_n = get_top_n_isoforms(sicelore_mouse_data_copy, gene_id='Akap9', strip=True, top_n=2)\ntp.draw_transcripts_list(top_n, draw_cds=True)\n\n\n\n\n\n\n\n\n\ntop_n = get_top_n_isoforms(sicelore_mouse_data_copy, gene_id='Akap9', strip=False, top_n=2)\n\nvs.plot_transcripts(sicelore_mouse_data_copy, transcripts=top_n)\n\n\n\n\n\n\n\n\n\nvs.plot_density_multi(sicelore_mouse_data_copy, features=top_n)\n\n\n\n\n\n\n\n\n\ntop_n = get_top_n_isoforms(sicelore_mouse_data_copy, gene_id='Cd63', strip=True, top_n=4)\ntp.draw_transcripts_list(top_n, draw_cds=True)\n\n\n\n\n\n\n\n\n\ntop_n\n\n['ENSMUST00000026407',\n 'ENSMUST00000219317',\n 'ENSMUST00000105229',\n 'ENSMUST00000220308']",
    "crumbs": [
      "Allos"
    ]
  },
  {
    "objectID": "readers_tests.html",
    "href": "readers_tests.html",
    "title": "Readers",
    "section": "",
    "text": "source\n\nget_resource_path\n\n get_resource_path (filename)\n\nDynamically find the correct path to the ‘resources/’ directory based on execution location.\n\nfile_path = get_resource_path(\"e18.mouse.clusters.csv\")\n\n\n🔎 Looking for file at: /data/analysis/data_mcandrew/allos_2/allos/resources/e18.mouse.clusters.csv\n✅ File found at: /data/analysis/data_mcandrew/allos_2/allos/resources/e18.mouse.clusters.csv\n\n\n\nsource\n\n\ndownload_test_data\n\n download_test_data (url:str='https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM\n                     3748nnn/GSM3748087/suppl/GSM3748087%5F190c.isoforms.m\n                     atrix.txt.gz', output_filename:str=None,\n                     decompress:bool=True)\n\nDownload test data to the correct directory, dynamically adjusting based on the execution context. Optionally decompresses gzip files if detected.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nurl\nstr\nhttps://ftp.ncbi.nlm.nih.gov/geo/samples/GSM3748nnn/GSM3748087/suppl/GSM3748087%5F190c.isoforms.matrix.txt.gz\nURL to download the data from.\n\n\noutput_filename\nstr\nNone\nName of the file to save the data as (default: name from the URL).\n\n\ndecompress\nbool\nTrue\nWhether to decompress the file if it is a gzip archive (default True).\n\n\nReturns\nstr\n\nPath to the downloaded or decompressed file.\n\n\n\n\nsource\n\n\niso_concat\n\n iso_concat (data_inputs, batch_info=None, batch_type='path')\n\n*Concatenates a list of AnnData objects or paths to AnnData objects based on the union of transcriptIds, while preserving geneId information which might be non-unique per transcriptId. Missing values are filled with zeros. Adds a batch column to .obs based on the file path, obs_names, or numeric.\nParameters: data_inputs (list of str or AnnData): List of paths to AnnData objects or AnnData objects to concatenate. batch_info (list of str, optional): List of batch identifiers for each AnnData object in data_inputs. If not provided, batch identifiers are extracted from file paths, obs_names, or a numeric sequence. batch_type (str, optional): Specifies which type of batch information to use. One of [‘path’, ‘obs_names’, ‘numeric’]. Defaults to ‘path’.\nReturns: AnnData: A single concatenated AnnData object with harmonized features, geneId annotations, and batch info.*\n\nsource\n\n\nread_sicelore_isomatrix\n\n read_sicelore_isomatrix (file_path:str, gene_id_label:str='geneId',\n                          transcript_id_label:str='transcriptId',\n                          remove_undef:bool=True, sparse:bool=False)\n\nRead a SiCeLoRe isomatrix file (tab-delimited) and convert it into a scanpy-compatible AnnData object.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfile_path\nstr\n\nPath to the isomatrix file (tab-delimited).\n\n\ngene_id_label\nstr\ngeneId\nRow/column label used for gene IDs (default “geneId”).\n\n\ntranscript_id_label\nstr\ntranscriptId\nRow/column label used for transcript IDs (default “transcriptId”).\n\n\nremove_undef\nbool\nTrue\nWhether to remove rows with transcriptId=“undef” (default True).\n\n\nsparse\nbool\nFalse\nWhether to store the matrix in sparse format (default False).\n\n\nReturns\nAnnData\n\nAn AnnData object containing numeric data in .X and metadata in .var.\n\n\n\n\nsource\n\n\nprocess_mouse_data\n\n process_mouse_data ()\n\n*Downloads test data, reads two mouse isoform count matrices, and merges them into a single AnnData object. It also reads a CSV file containing barcode-to-cell_type mappings, merges this information into the AnnData object’s obs DataFrame, and filters out entries with no cell_type assigned.\nReturns: combined_mouse_data (AnnData): The merged and annotated AnnData object.*\n\nmouse_data = process_mouse_data()\n\n\n🔎 Looking for file at: /data/analysis/data_mcandrew/allos_2/allos/resources/e18.mouse.clusters.csv\n✅ File found at: /data/analysis/data_mcandrew/allos_2/allos/resources/e18.mouse.clusters.csv\n✅ File already exists at: /data/analysis/data_mcandrew/allos_2/allos/nbs/data/mouse_1.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/allos_2/allos/nbs/data/mouse_1.txt.gz to /data/analysis/data_mcandrew/allos_2/allos/nbs/data/mouse_1.txt...\n✅ Decompression complete.\nTest data (mouse_1) downloaded successfully\n✅ File already exists at: /data/analysis/data_mcandrew/allos_2/allos/nbs/data/mouse_2.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/allos_2/allos/nbs/data/mouse_2.txt.gz to /data/analysis/data_mcandrew/allos_2/allos/nbs/data/mouse_2.txt...\n✅ Decompression complete.\nTest data (mouse_2) downloaded successfully\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/anndata/_core/anndata.py:1754: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n  utils.warn_names_duplicates(\"obs\")\n\n\n\nfile_path = get_resource_path(\"e18.mouse.clusters.csv\")\ndf = pd.read_csv(file_path)\ndf['barcode'] = df.index.str.split('_').str[1]\n\n\nmouse_data_str_1 = download_test_data(output_filename='mouse_1.txt.gz')\nprint(\"Test data downloaded successfully\")\n\n\nmouse_data_str_2 = download_test_data(\"https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM3748nnn/GSM3748089/suppl/GSM3748089%5F951c.isoforms.matrix.txt.gz\", output_filename='mouse_2.txt.gz')\nprint(\"Test data downloaded successfully\")\n\n\nmouse_1 = read_sicelore_isomatrix(file_path=mouse_data_str_1)\nmouse_2 = read_sicelore_isomatrix(file_path=mouse_data_str_2)\n\ncombined_mouse_data = iso_concat([mouse_1, mouse_2], batch_type='numeric')\n\n\ncombined_mouse_data.obs_names_make_unique()\n# Step 1: Remove any duplicate barcodes in the DataFrame\ndf_unique = df.drop_duplicates(subset='barcode')\n\n# Step 2: Filter the DataFrame to include only the barcodes present in the AnnData object\ndf_filtered = df_unique[df_unique['barcode'].isin(combined_mouse_data.obs_names)]\n\n# Step 3: Set the index of the filtered DataFrame to 'barcode' to make the merge easier\ndf_filtered.set_index('barcode', inplace=True)\n\n# Step 4: Create a DataFrame from the obs DataFrame of the AnnData object to ensure the same index\nobs_df = combined_mouse_data.obs.copy()\n\n# Step 5: Initialize a new column 'cell_type' with NaN values in the obs DataFrame\nobs_df['cell_type'] = pd.NA\n\n# Step 6: Update the 'cell_type' column with values from the filtered DataFrame where indices match\nobs_df.update(df_filtered['illumina.ident'].rename('cell_type'))\n\n# Step 7: Ensure the index is unique and assign the updated DataFrame back to the obs attribute of the AnnData object\nif obs_df.index.is_unique:\n    combined_mouse_data.obs = obs_df\nelse:\n    raise ValueError(\"The index of the obs DataFrame is not unique.\")\n\n# Now, the 'cell_type' column should be added to the obs DataFrame of your AnnData object\ncombined_mouse_data = combined_mouse_data[~combined_mouse_data.obs['cell_type'].isna()]\n\n\n🔎 Looking for file at: /data/analysis/data_mcandrew/allos_2/allos/resources/e18.mouse.clusters.csv\n✅ File found at: /data/analysis/data_mcandrew/allos_2/allos/resources/e18.mouse.clusters.csv\n\n🔄 Downloading https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM3748nnn/GSM3748087/suppl/GSM3748087%5F190c.isoforms.matrix.txt.gz to /data/analysis/data_mcandrew/allos_2/allos/nbs/data/mouse_1.txt.gz...\n✅ Download complete.\n\n🔄 Decompressing /data/analysis/data_mcandrew/allos_2/allos/nbs/data/mouse_1.txt.gz to /data/analysis/data_mcandrew/allos_2/allos/nbs/data/mouse_1.txt...\n✅ Decompression complete.\nTest data downloaded successfully\n\n🔄 Downloading https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM3748nnn/GSM3748089/suppl/GSM3748089%5F951c.isoforms.matrix.txt.gz to /data/analysis/data_mcandrew/allos_2/allos/nbs/data/mouse_2.txt.gz...\n✅ Download complete.\n\n🔄 Decompressing /data/analysis/data_mcandrew/allos_2/allos/nbs/data/mouse_2.txt.gz to /data/analysis/data_mcandrew/allos_2/allos/nbs/data/mouse_2.txt...\n✅ Decompression complete.\nTest data downloaded successfully\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/anndata/_core/anndata.py:1754: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n  utils.warn_names_duplicates(\"obs\")\n\n\n\nmouse_data_str_1\n\n'/data/analysis/data_mcandrew/allos_2/allos/nbs/data/mouse_1.txt'\n\n\n\ncombined_mouse_data\n\nView of AnnData object with n_obs × n_vars = 1109 × 31986\n    obs: 'batch', 'cell_type'\n    var: 'geneId'",
    "crumbs": [
      "Readers"
    ]
  },
  {
    "objectID": "preprocesing.html",
    "href": "preprocesing.html",
    "title": "Preprocessing",
    "section": "",
    "text": "source\n\nsubset_common_cells\n\n subset_common_cells (dataset1:anndata._core.anndata.AnnData,\n                      dataset2:anndata._core.anndata.AnnData)\n\nSubset dataset1 to only include cells that are also present in dataset2.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndataset1\nAnnData\nFirst dataset to be subsetted.\n\n\ndataset2\nAnnData\nSecond dataset to compare with.\n\n\nReturns\nAnnData\nSubset of dataset1 containing only cells also found in dataset2.\n\n\n\n\nsource\n\n\ntransfer_obs\n\n transfer_obs (dataset1:anndata._core.anndata.AnnData,\n               dataset2:anndata._core.anndata.AnnData)\n\nTransfer .obs metadata from dataset1 to dataset2 one by one, while preserving the .var DataFrame of dataset2.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndataset1\nAnnData\nSource AnnData object with .obs metadata to transfer.\n\n\ndataset2\nAnnData\nTarget AnnData object to receive .obs metadata.\n\n\nReturns\nAnnData\nThe modified dataset2 with .obs from dataset1 transferred.\n\n\n\n\ncombined_mouse_data = process_mouse_data()\n\n\n🔎 Looking for file at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File found at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/e18.mouse.clusters.csv\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_1.txt...\n✅ Decompression complete.\nTest data (mouse_1) downloaded successfully\n✅ File already exists at: /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz\n\n🔄 Decompressing /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt.gz to /data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/allos/resources/data/mouse_2.txt...\n✅ Decompression complete.\nTest data (mouse_2) downloaded successfully\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/anndata/_core/anndata.py:1754: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n  utils.warn_names_duplicates(\"obs\")\n\n\n\nsource\n\n\nget_sot_gene_matrix\n\n get_sot_gene_matrix (adata)\n\nConstruct a gene-level count matrix from transcript-level data.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nadata\nAnnData\nInput AnnData with transcript-level counts. Must have a column geneIdin adata.var containing the gene ID for each transcript.\n\n\nReturns\nAnnData\nA new AnnData object where columns (var) represent unique genes, and values are aggregated transcript counts.\n\n\n\n\nsource\n\n\ncompute_transcript_abundance_pct\n\n compute_transcript_abundance_pct (adata)\n\n*Compute transcript abundance percentages (“percent spliced in”) for each transcript within its gene. For each cell and transcript, this is computed as:\ntranscript_pct = (transcript count / total gene count) * 100*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nadata\nAnnData\nAnnData object with transcript-level counts. Must have a column ‘geneId’ in adata.var.\n\n\nReturns\nAnnData\nA new AnnData object with the same obs and var as the input, where X holds transcript abundance percentages.\n\n\n\n\nsource\n\n\ncompute_whole_data_transcript_abundance\n\n compute_whole_data_transcript_abundance (adata)\n\n*Compute transcript abundance percentages for the entire dataset by aggregating transcript counts across all cells into a single composite sample.\nThis function sums the transcript counts over all cells, constructs a new AnnData with a single observation, and then computes transcript abundance percentages using compute_transcript_abundance_pct.*\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nadata\nAnnData\nAnnData object with transcript-level counts. Must have a ‘geneId’ column in adata.var.\n\n\nReturns\nAnnData\nA new AnnData object with one observation representing the aggregated data where X holds transcript abundance percentages.\n\n\n\n\nsource\n\n\nfilter_transcripts_by_abundance\n\n filter_transcripts_by_abundance (adata, threshold_pct, verbose=False)\n\n*Filter transcripts from an AnnData object based on their overall transcript abundance percentage, computed by aggregating transcript counts across all cells and leveraging overall gene counts.\nThe overall abundance percentage for each transcript is calculated as:\noverall_pct = (total transcript count) / (total gene count for its gene) * 100\nThis function uses the compute_whole_data_transcript_abundance function internally to leverage the gene mapping information (via the ‘geneId’ in adata.var). Transcripts with an overall abundance percentage below the specified threshold (threshold_pct) are filtered out.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nadata\nAnnData\n\nAnnData object with transcript-level counts. Must have a ‘geneId’ column in adata.var.\n\n\nthreshold_pct\nfloat\n\nMinimum overall transcript abundance percentage required to keep a transcript.\n\n\nverbose\nbool\nFalse\nIf True, prints the number of transcripts kept and the threshold used. Default is False.\n\n\nReturns\nAnnData\n\nA new AnnData object with the filtered transcript matrix.\n\n\n\n\ncombined_mouse_data_filtered = filter_transcripts_by_abundance(combined_mouse_data, threshold_pct= 2)\n\n\ncombined_mouse_data_filtered\n\nAnnData object with n_obs × n_vars = 1109 × 24917\n    obs: 'batch', 'cell_type'\n    var: 'geneId'\n\n\n\ncombined_mouse_data\n\nView of AnnData object with n_obs × n_vars = 1109 × 31986\n    obs: 'batch', 'cell_type'\n    var: 'geneId'\n\n\n\ngene_adata = get_sot_gene_matrix(combined_mouse_data)\n\n\ngene_adata\n\nAnnData object with n_obs × n_vars = 1109 × 12561\n    obs: 'batch', 'cell_type'\n\n\n/data/analysis/data_mcandrew/Allos_new/allos_env/lib/python3.9/site-packages/fastcore/docscrape.py:230: UserWarning: Unknown section Note\n  else: warn(msg)\n\nsource\n\n\ngene_wise_correlation\n\n gene_wise_correlation (adata_1, adata_2, label_1='Short_Reads',\n                        label_2='Long_Reads', density_hist=True,\n                        facet_obs=None)\n\nGeneralized function to compute gene-level counts for each dataset, merge them, and plot a log correlation. If facet_obs is specified, creates per-category plots.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nadata_1\nAnnData\n\nFirst AnnData, presumably transcript-level. Must have a ‘geneId’ column in .var.\n\n\nadata_2\nAnnData\n\nSecond AnnData, presumably transcript-level. Must have a ‘geneId’ column in .var.\n\n\nlabel_1\nstr\nShort_Reads\nLabel for the first dataset in the merged DataFrame and on plots.\n\n\nlabel_2\nstr\nLong_Reads\nLabel for the second dataset in the merged DataFrame and on plots.\n\n\ndensity_hist\nbool\nTrue\nIf True, display a scatter with marginal histograms. Otherwise, just a scatter.\n\n\nfacet_obs\nNoneType\nNone\nIf provided, facet by the unique categories in adata_1.obs[facet_obs] andsubset adata_2 identically, producing one subplot per category.\n\n\nReturns\npd.DataFrame\n\n- If facet_obs is None: a DataFrame of shape [n_genes, 5] with columns: [‘gene_name’, label_1, label_2, ‘log_x’, ‘log_y’].- If facet_obs is not None: a concatenated DataFrame of all categories, with an extra column ‘facet’ indicating the category.\n\n\n\n\ngene_wise_correlation(adata_1=gene_adata, adata_2=combined_mouse_data, label_1=\"gene matrix\", label_2 = \"isoform matrix\", density_hist = True, facet_obs = \"cell_type\")\n\n\n\n\n\n\n\n\n\nsource\n\n\ngene_wise_bland_altman\n\n gene_wise_bland_altman (adata_1, adata_2, label_1='Short_Reads',\n                         label_2='Long_Reads', facet_obs=None)\n\n*Similar logic to gene_wise_correlation, but produces a Bland–Altman plot of the log1p-transformed gene counts. If facet_obs is given, one subplot per category.\nSteps: 1) (Optionally) convert each AnnData to gene-level if needed. 2) Sum counts across cells in each AnnData. 3) Merge on gene_name. 4) Bland–Altman: difference vs. mean of log1p(counts).*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nadata_1\nAnnData\n\n\n\n\nadata_2\nAnnData\n\nBoth should be gene-level or convertible to gene-level (e.g., via get_sot_gene_matrix).\n\n\nlabel_1\nstr\nShort_Reads\nLabel for the first dataset in merged outputs & plot axes.\n\n\nlabel_2\nstr\nLong_Reads\nLabel for the second dataset in merged outputs & plot axes.\n\n\nfacet_obs\nNoneType\nNone\nIf not None, create one subplot per category in adata_1.obs[facet_obs].\n\n\nReturns\npd.DataFrame\n\n- If facet_obs is None: a single DataFrame with columns [gene_name, label_1, label_2, log_x, log_y, mean_val, diff_val].- If facet_obs is not None: concatenated DataFrame with all categories, plus ‘facet’ indicating each category.\n\n\n\n\ngene_wise_bland_altman(adata_1=gene_adata, adata_2=combined_mouse_data, label_1=\"gene matrix\", label_2 = \"isoform matrix\", facet_obs = \"cell_type\")\n\n\n\n\n\n\n\n\n\nimport nbdev; nbdev.nbdev_export()",
    "crumbs": [
      "Preprocessing"
    ]
  }
]